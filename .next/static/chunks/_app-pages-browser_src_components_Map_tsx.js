"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_Map_tsx"],{

/***/ 6785:
/*!********************************!*\
  !*** ./src/components/Map.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ 3068);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ 2265);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maplibre-gl */ 7762);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(maplibre_gl__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/helpers */ 2630);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n/**\r\n * Map Component - MapLibre GL JS map with globe projection and multi-location support\r\n * Updated for Next.js - no hash routing, uses localStorage for map state\r\n */ \n\n\nconst Map = /*#__PURE__*/ _s((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = _s((param, ref)=>{\n    let { selectedMovie, onMovieSelect, searchQuery: _searchQuery, filters, focusedMovieId, onClearFocus } = param;\n    _s();\n    const mapContainer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [movies, setMovies] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [geojsonFeatures, setGeojsonFeatures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const initializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Track which poster images have been loaded to prevent redundant loading\n    const loadedImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Loading state for progressive rendering\n    const [loadingState, setLoadingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        isLoading: true,\n        progress: 0,\n        stage: \"Initializing...\"\n    });\n    // Expose methods to parent component\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, ()=>({\n            showAllLocationsForMovie: (movie)=>{\n                const feature = geojsonFeatures.find((f)=>f.properties.movie_id === movie.movie_id);\n                if (feature) {\n                    showAllLocations(feature);\n                }\n            },\n            flyToLocation: (lat, lng)=>{\n                if (map.current) {\n                    map.current.flyTo({\n                        center: [\n                            lng,\n                            lat\n                        ],\n                        zoom: 12,\n                        duration: 2000,\n                        essential: true\n                    });\n                }\n            }\n        }));\n    /**\r\n   * Convert GeoJSON feature to Movie object\r\n   */ const convertFeatureToMovie = (feature)=>{\n        // Extract locations from geometry\n        let locations = [];\n        if (feature.geometry.type === \"Point\") {\n            var _feature_properties_location_names_, _feature_properties_location_names__split_, _feature_properties_location_names_1, _feature_properties_location_names__match, _feature_properties_location_names_2;\n            const [lng, lat] = feature.geometry.coordinates;\n            locations = [\n                {\n                    lat,\n                    lng,\n                    city: ((_feature_properties_location_names_ = feature.properties.location_names[0]) === null || _feature_properties_location_names_ === void 0 ? void 0 : _feature_properties_location_names_.split(\",\")[0]) || \"Unknown\",\n                    country: ((_feature_properties_location_names_1 = feature.properties.location_names[0]) === null || _feature_properties_location_names_1 === void 0 ? void 0 : (_feature_properties_location_names__split_ = _feature_properties_location_names_1.split(\",\")[1]) === null || _feature_properties_location_names__split_ === void 0 ? void 0 : _feature_properties_location_names__split_.trim()) || \"Unknown\",\n                    description: ((_feature_properties_location_names_2 = feature.properties.location_names[0]) === null || _feature_properties_location_names_2 === void 0 ? void 0 : (_feature_properties_location_names__match = _feature_properties_location_names_2.match(/\\((.*?)\\)/)) === null || _feature_properties_location_names__match === void 0 ? void 0 : _feature_properties_location_names__match[1]) || \"\"\n                }\n            ];\n        } else if (feature.geometry.type === \"MultiPoint\") {\n            const coords = feature.geometry.coordinates;\n            locations = coords.map((coord, idx)=>{\n                var _locationName_match;\n                const [lng, lat] = coord;\n                const locationName = feature.properties.location_names[idx] || \"Unknown\";\n                const [city, country] = locationName.split(\",\").map((s)=>s.trim());\n                const description = ((_locationName_match = locationName.match(/\\((.*?)\\)/)) === null || _locationName_match === void 0 ? void 0 : _locationName_match[1]) || \"\";\n                return {\n                    lat,\n                    lng,\n                    city: city || \"Unknown\",\n                    country: country || \"Unknown\",\n                    description\n                };\n            });\n        }\n        return {\n            movie_id: feature.properties.movie_id,\n            title: feature.properties.title,\n            year: feature.properties.year,\n            imdb_id: feature.properties.movie_id,\n            tmdb_id: String(feature.properties.tmdb_id),\n            genres: feature.properties.genres || (feature.properties.top_genre ? [\n                feature.properties.top_genre\n            ] : []),\n            poster: feature.properties.poster || undefined,\n            trailer: feature.properties.trailer || undefined,\n            imdb_rating: feature.properties.imdb_rating || undefined,\n            locations\n        };\n    };\n    /**\r\n   * Load movies data and GeoJSON with progressive loading\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            try {\n                // Load GeoJSON features\n                const geojsonResponse = await fetch(\"/geo/movies.geojson\");\n                const geojsonData = await geojsonResponse.json();\n                // Store all features for filtering\n                setGeojsonFeatures(geojsonData.features);\n                // Convert all GeoJSON features to Movie objects\n                const moviesFromGeoJSON = geojsonData.features.map(convertFeatureToMovie);\n                setMovies(moviesFromGeoJSON);\n                console.log(\"\\uD83D\\uDCCA Loaded \".concat(geojsonData.features.length, \" movies for progressive rendering\"));\n            } catch (error) {\n                console.error(\"Failed to load data:\", error);\n            }\n        };\n        loadData();\n    }, []);\n    /**\r\n   * Initialize map\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapContainer.current || map.current) return;\n        map.current = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Map)({\n            container: mapContainer.current,\n            // Use MapTiler basic style - free tier, works with globe\n            style: \"https://api.maptiler.com/maps/basic-v2/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL\",\n            zoom: 2.88,\n            center: [\n                0.35,\n                43\n            ]\n        });\n        // Globe rotation animation\n        let isUserInteracting = false;\n        let rotationAnimation = null;\n        const startRotation = ()=>{\n            if (!map.current || isUserInteracting) return;\n            const rotateCamera = (_timestamp)=>{\n                if (!map.current || isUserInteracting) return;\n                // Rotate 360 degrees over 2 minutes (120 seconds)\n                const secondsPerRevolution = 720;\n                const center = map.current.getCenter();\n                center.lng = (center.lng + 360 / secondsPerRevolution * (1 / 60)) % 360;\n                map.current.setCenter(center);\n                rotationAnimation = requestAnimationFrame(rotateCamera);\n            };\n            rotationAnimation = requestAnimationFrame(rotateCamera);\n        };\n        const stopRotation = ()=>{\n            isUserInteracting = true;\n            if (rotationAnimation !== null) {\n                cancelAnimationFrame(rotationAnimation);\n                rotationAnimation = null;\n            }\n        };\n        map.current.on(\"style.load\", ()=>{\n            if (map.current) {\n                // Set projection to globe\n                map.current.setProjection({\n                    type: \"globe\"\n                });\n                // Restore map position from localStorage (clean URLs)\n                if (true) {\n                    const savedState = localStorage.getItem(\"cinemap_view\");\n                    if (savedState) {\n                        try {\n                            const { lat, lng, zoom } = JSON.parse(savedState);\n                            map.current.setCenter([\n                                lng,\n                                lat\n                            ]);\n                            map.current.setZoom(zoom);\n                        } catch (e) {\n                        // Ignore invalid stored state\n                        }\n                    }\n                }\n                // Start rotation after map loads\n                setTimeout(startRotation, 1000);\n            }\n        });\n        // Save map position to localStorage on movement (debounced)\n        let saveTimeout = null;\n        const saveMapState = ()=>{\n            if (!map.current || \"object\" === \"undefined\") return;\n            const center = map.current.getCenter();\n            const zoom = map.current.getZoom();\n            localStorage.setItem(\"cinemap_view\", JSON.stringify({\n                lat: center.lat,\n                lng: center.lng,\n                zoom: zoom\n            }));\n        };\n        map.current.on(\"moveend\", ()=>{\n            if (saveTimeout) clearTimeout(saveTimeout);\n            saveTimeout = setTimeout(saveMapState, 500);\n        });\n        // Stop rotation on any user interaction\n        map.current.on(\"mousedown\", stopRotation);\n        map.current.on(\"touchstart\", stopRotation);\n        map.current.on(\"wheel\", stopRotation);\n        map.current.on(\"dragstart\", stopRotation);\n        // Add navigation controls\n        map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().NavigationControl)(), \"bottom-right\");\n        map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().FullscreenControl)(), \"bottom-right\");\n        // Don't add zoom listener here - it causes issues with tile loading\n        // We'll handle it differently\n        return ()=>{\n            if (map.current) {\n                map.current.remove();\n                map.current = null;\n            }\n        };\n    }, []);\n    /**\r\n   * Load and create poster image icon with movie badge\r\n   */ const createPosterIcon = async (posterPath, _movieId, _isMultiLocation)=>{\n        return new Promise((resolve)=>{\n            const size = 60 // Consistent size for all markers\n            ;\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = size;\n            canvas.height = size;\n            const ctx = canvas.getContext(\"2d\");\n            // If no poster, create fallback icon\n            if (!posterPath) {\n                // Create circular background\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.fillStyle = \"#3B82F6\";\n                ctx.fill();\n                // White border\n                ctx.strokeStyle = \"#FFFFFF\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                // Film icon\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.font = \"bold 24px Arial\";\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillText(\"\\uD83C\\uDFAC\", size / 2, size / 2);\n                resolve({\n                    width: size,\n                    height: size,\n                    data: ctx.getImageData(0, 0, size, size).data\n                });\n                return;\n            }\n            // Load poster image\n            const img = new Image();\n            img.crossOrigin = \"anonymous\";\n            img.onload = ()=>{\n                // Create circular clipping mask\n                ctx.save();\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.clip();\n                // Draw poster (centered and scaled)\n                ctx.drawImage(img, 0, 0, size, size);\n                ctx.restore();\n                // White border around circle\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.strokeStyle = \"#10be50ff\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                resolve({\n                    width: size,\n                    height: size,\n                    data: ctx.getImageData(0, 0, size, size).data\n                });\n            };\n            img.onerror = ()=>{\n                // Fallback on error - circular icon\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.fillStyle = \"#3B82F6\";\n                ctx.fill();\n                ctx.strokeStyle = \"#FFFFFF\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                // Film icon fallback\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.font = \"bold 20px Arial\";\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillText(\"\\uD83C\\uDFAC\", size / 2, size / 2);\n                resolve({\n                    width: size,\n                    height: size,\n                    data: ctx.getImageData(0, 0, size, size).data\n                });\n            };\n            // Use the full poster URL from the data\n            img.src = posterPath;\n        });\n    };\n    /**\r\n   * Show all locations for a movie\r\n   */ const showAllLocations = (feature)=>{\n        if (!map.current) return;\n        const coordinates = feature.geometry.type === \"MultiPoint\" ? feature.geometry.coordinates : [\n            feature.geometry.coordinates\n        ];\n        // Calculate bounds\n        const bounds = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().LngLatBounds)();\n        coordinates.forEach((coord)=>bounds.extend(coord));\n        // Fit map to bounds\n        map.current.fitBounds(bounds, {\n            padding: 100,\n            maxZoom: 10,\n            duration: 1000\n        });\n        // Remove existing connecting line\n        if (map.current.getLayer(\"connecting-line\")) {\n            map.current.removeLayer(\"connecting-line\");\n        }\n        if (map.current.getSource(\"connecting-line\")) {\n            map.current.removeSource(\"connecting-line\");\n        }\n        // Draw connecting polyline for multi-location movies\n        if (coordinates.length > 1) {\n            map.current.addSource(\"connecting-line\", {\n                type: \"geojson\",\n                data: {\n                    type: \"Feature\",\n                    geometry: {\n                        type: \"LineString\",\n                        coordinates\n                    },\n                    properties: {}\n                }\n            });\n            map.current.addLayer({\n                id: \"connecting-line\",\n                type: \"line\",\n                source: \"connecting-line\",\n                paint: {\n                    \"line-color\": \"#F59E0B\",\n                    \"line-width\": 4,\n                    \"line-opacity\": 0.9,\n                    \"line-blur\": 1\n                }\n            });\n        // Keep line visible permanently\n        }\n    };\n    /**\r\n   * Add movie markers from GeoJSON - INITIAL LOAD ONLY\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current || geojsonFeatures.length === 0) return;\n        // Only run this effect once when data is first loaded\n        if (initializedRef.current || map.current.getSource(\"movies\")) return;\n        async function initializeMarkers() {\n            if (!map.current) return;\n            // Load ALL posters BEFORE adding map layer (prevents warnings)\n            const BATCH_SIZE = 20;\n            let loadedCount = 0;\n            const allFeatures = geojsonFeatures;\n            // Only show loading on initial setup, not on StrictMode re-mounts\n            if (!initializedRef.current) {\n                setLoadingState({\n                    isLoading: true,\n                    progress: 90,\n                    stage: \"Loading posters... 0/\".concat(allFeatures.length)\n                });\n            }\n            // Load posters in batches and await completion\n            for(let i = 0; i < allFeatures.length; i += BATCH_SIZE){\n                const batch = allFeatures.slice(i, i + BATCH_SIZE);\n                await Promise.all(batch.map(async (feature)=>{\n                    const movieId = feature.properties.movie_id;\n                    const posterPath = feature.properties.poster;\n                    const isMultiLocation = feature.properties.locations_count > 1;\n                    const iconName = \"poster-\".concat(movieId);\n                    if (!map.current.hasImage(iconName)) {\n                        try {\n                            const posterIcon = await createPosterIcon(posterPath, movieId, isMultiLocation);\n                            map.current.addImage(iconName, posterIcon);\n                            loadedImagesRef.current.add(iconName) // Mark as loaded\n                            ;\n                            loadedCount++;\n                        } catch (error) {\n                            console.error(\"Failed to add poster icon for \".concat(movieId, \":\"), error);\n                            // Add fallback icon on error\n                            const fallbackIcon = await createPosterIcon(null, movieId, isMultiLocation);\n                            map.current.addImage(iconName, fallbackIcon);\n                            loadedImagesRef.current.add(iconName) // Mark as loaded\n                            ;\n                            loadedCount++;\n                        }\n                    } else {\n                        loadedCount++;\n                    }\n                }));\n                // Update progress after each batch\n                const progress = Math.round(loadedCount / allFeatures.length * 100);\n                setLoadingState({\n                    isLoading: true,\n                    progress: 90 + progress * 0.09,\n                    stage: \"Loading posters... \".concat(loadedCount, \"/\").concat(allFeatures.length)\n                });\n            }\n            // Show rendering stage only on initial setup\n            if (!initializedRef.current) {\n                setLoadingState({\n                    isLoading: true,\n                    progress: 99,\n                    stage: \"Rendering markers...\"\n                });\n            }\n            // Convert MultiPoint features into individual Point features for each location\n            const displayFeatures = [];\n            allFeatures.forEach((feature)=>{\n                if (feature.geometry.type === \"MultiPoint\") {\n                    // Create a separate feature for each location\n                    const coords = feature.geometry.coordinates;\n                    coords.forEach((coord, index)=>{\n                        displayFeatures.push({\n                            ...feature,\n                            id: \"\".concat(feature.id, \"-loc-\").concat(index),\n                            geometry: {\n                                type: \"Point\",\n                                coordinates: coord\n                            }\n                        });\n                    });\n                } else {\n                    // Single location - keep as is\n                    displayFeatures.push(feature);\n                }\n            });\n            // Create GeoJSON for display\n            const geojson = {\n                type: \"FeatureCollection\",\n                features: displayFeatures\n            };\n            // Add source - DISABLE clustering so markers stay visible\n            map.current.addSource(\"movies\", {\n                type: \"geojson\",\n                data: geojson,\n                // Clustering disabled - we want to see all markers\n                cluster: false\n            });\n            // Add all movie markers layer (now each marker represents one actual location)\n            map.current.addLayer({\n                id: \"movie-markers\",\n                type: \"symbol\",\n                source: \"movies\",\n                layout: {\n                    \"icon-image\": [\n                        \"concat\",\n                        \"poster-\",\n                        [\n                            \"get\",\n                            \"movie_id\"\n                        ]\n                    ],\n                    \"icon-size\": 0.7,\n                    \"icon-allow-overlap\": true,\n                    \"text-field\": [\n                        \"get\",\n                        \"title\"\n                    ],\n                    \"text-font\": [\n                        \"Open Sans Bold\",\n                        \"Arial Unicode MS Bold\"\n                    ],\n                    \"text-size\": 14,\n                    \"text-offset\": [\n                        0,\n                        2.8\n                    ],\n                    \"text-anchor\": \"top\",\n                    \"text-max-width\": 12,\n                    \"text-allow-overlap\": false\n                },\n                paint: {\n                    \"text-color\": \"#10be50ff\",\n                    \"text-halo-color\": \"#1F2937\",\n                    \"text-halo-width\": 2.5,\n                    \"text-halo-blur\": 1\n                }\n            });\n            // All done - hide loading screen only on initial setup\n            if (!initializedRef.current) {\n                setTimeout(()=>{\n                    setLoadingState({\n                        isLoading: false,\n                        progress: 100,\n                        stage: \"Complete\"\n                    });\n                    initializedRef.current = true;\n                }, 300) // Small delay for smooth transition\n                ;\n            }\n            // Add unified click handler for all movie markers\n            const handleMarkerClick = (e)=>{\n                if (!e.features || e.features.length === 0) return;\n                const feature = e.features[0];\n                // Try to find in geojsonFeatures by movie_id\n                const featureByMovieId = geojsonFeatures.find((f)=>f.properties.movie_id === feature.properties.movie_id);\n                if (featureByMovieId) {\n                    const movieFromFeature = convertFeatureToMovie(featureByMovieId);\n                    onMovieSelect(movieFromFeature);\n                    // Show all locations for multi-location movies\n                    if (featureByMovieId.properties.locations_count > 1) {\n                        setTimeout(()=>showAllLocations(featureByMovieId), 500);\n                    }\n                } else {\n                    // Last resort: create a minimal movie object\n                    const movieFromClick = {\n                        movie_id: feature.properties.movie_id,\n                        title: feature.properties.title,\n                        year: feature.properties.year,\n                        imdb_id: feature.properties.movie_id,\n                        tmdb_id: String(feature.properties.tmdb_id),\n                        genres: feature.properties.genres || (feature.properties.top_genre ? [\n                            feature.properties.top_genre\n                        ] : []),\n                        poster: feature.properties.poster || undefined,\n                        trailer: feature.properties.trailer || undefined,\n                        imdb_rating: feature.properties.imdb_rating || undefined,\n                        locations: [\n                            {\n                                lat: 0,\n                                lng: 0,\n                                city: \"Unknown\",\n                                country: \"Unknown\"\n                            }\n                        ]\n                    };\n                    onMovieSelect(movieFromClick);\n                }\n            };\n            map.current.on(\"click\", \"movie-markers\", handleMarkerClick);\n            // Clear focus when clicking on empty map (not on markers)\n            const handleMapClick = (e)=>{\n                // Only clear focus if clicking on empty space (not on markers)\n                if (!e.features || e.features.length === 0) {\n                    if (focusedMovieId && onClearFocus) {\n                        onClearFocus();\n                    }\n                }\n            };\n            map.current.on(\"click\", handleMapClick);\n            // Change cursor on hover\n            map.current.on(\"mouseenter\", \"movie-markers\", ()=>{\n                map.current.getCanvas().style.cursor = \"pointer\";\n            });\n            map.current.on(\"mouseleave\", \"movie-markers\", ()=>{\n                map.current.getCanvas().style.cursor = \"\";\n            });\n        }\n        // Wait for style to be loaded\n        if (!map.current.isStyleLoaded()) {\n            map.current.on(\"load\", ()=>{\n                initializeMarkers();\n            });\n        } else {\n            initializeMarkers();\n        }\n    }, [\n        geojsonFeatures\n    ]) // Only depend on geojsonFeatures - run once when data loads\n    ;\n    /**\r\n   * Update visible markers based on filters and focus - NO REBUILDING\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current || !map.current.getSource(\"movies\")) return;\n        let filteredFeatures;\n        // If a movie is focused, ONLY show that movie's markers (ignore all other filters)\n        if (focusedMovieId) {\n            filteredFeatures = geojsonFeatures.filter((f)=>f.properties.movie_id === focusedMovieId);\n        } else {\n            // Normal mode: apply search and filter logic\n            const filteredMovies = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.filterMovies)(movies, filters);\n            const filteredIds = new Set(filteredMovies.map((m)=>m.movie_id));\n            filteredFeatures = movies.length > 0 ? geojsonFeatures.filter((f)=>filteredIds.has(f.properties.movie_id)) : geojsonFeatures;\n        }\n        // Convert MultiPoint features into individual Point features\n        const displayFeatures = [];\n        filteredFeatures.forEach((feature)=>{\n            if (feature.geometry.type === \"MultiPoint\") {\n                const coords = feature.geometry.coordinates;\n                coords.forEach((coord, index)=>{\n                    displayFeatures.push({\n                        ...feature,\n                        id: \"\".concat(feature.id, \"-loc-\").concat(index),\n                        geometry: {\n                            type: \"Point\",\n                            coordinates: coord\n                        }\n                    });\n                });\n            } else {\n                displayFeatures.push(feature);\n            }\n        });\n        // Update the data source WITHOUT rebuilding layers - INSTANT!\n        const geojson = {\n            type: \"FeatureCollection\",\n            features: displayFeatures\n        };\n        const source = map.current.getSource(\"movies\");\n        if (source && source.setData) {\n            source.setData(geojson);\n        }\n    }, [\n        geojsonFeatures,\n        movies,\n        filters,\n        focusedMovieId\n    ]) // Update data when filters/focus change\n    ;\n    /**\r\n   * Handle selected movie\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current || !selectedMovie) return;\n        const bounds = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().LngLatBounds)();\n        selectedMovie.locations.forEach((location)=>{\n            bounds.extend([\n                location.lng,\n                location.lat\n            ]);\n        });\n        map.current.fitBounds(bounds, {\n            padding: 100,\n            duration: 1000\n        });\n    }, [\n        selectedMovie\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"map-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"stars-background\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 716,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapContainer,\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    position: \"relative\",\n                    zIndex: 1\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 719,\n                columnNumber: 7\n            }, undefined),\n            loadingState.isLoading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 z-50 flex items-center justify-center bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-center space-y-6 px-8\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-7xl animate-bounce\",\n                            children: \"\\uD83C\\uDFAC\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 726,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-3xl font-bold text-white\",\n                            children: \"CineMap\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 731,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-xl text-gray-300\",\n                            children: loadingState.stage\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 736,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-80 bg-gray-700 rounded-full h-3 overflow-hidden\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"bg-gradient-to-r from-primary-500 to-purple-600 h-full transition-all duration-300 ease-out\",\n                                style: {\n                                    width: \"\".concat(loadingState.progress, \"%\")\n                                }\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                                lineNumber: 742,\n                                columnNumber: 15\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 741,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-sm text-gray-400 font-mono\",\n                            children: [\n                                Math.round(loadingState.progress),\n                                \"%\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 749,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                    lineNumber: 724,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 723,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-20 left-4 z-10 bg-black/70 backdrop-blur-sm text-white px-4 py-2 rounded-lg shadow-xl border border-white/10\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-2xl\",\n                            children: \"\\uD83C\\uDFAC\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 759,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-xs text-gray-300\",\n                                    children: \"Total Movies\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                                    lineNumber: 761,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-xl font-bold\",\n                                    children: movies.length\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                                    lineNumber: 762,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 760,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                    lineNumber: 758,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 757,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n        lineNumber: 714,\n        columnNumber: 5\n    }, undefined);\n}, \"5BTviUG6aMJ2VoWkRlsgRzX4ebk=\")), \"5BTviUG6aMJ2VoWkRlsgRzX4ebk=\");\n_c1 = Map;\nMap.displayName = \"Map\";\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\nvar _c, _c1;\n$RefreshReg$(_c, \"Map$forwardRef\");\n$RefreshReg$(_c1, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXlCLE9BQXRCeEcsYUFBYUcsUUFBUSxFQUFDO2dDQUFHOzs7Ozs7Ozs7OztzQ0FLaEQsOERBQUMrTDs0QkFBRUosV0FBVTs7Z0NBQ1ZoRixLQUFLd0QsS0FBSyxDQUFDdEssYUFBYUcsUUFBUTtnQ0FBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU8zQyw4REFBQzBMO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNLOzRCQUFLTCxXQUFVO3NDQUFXOzs7Ozs7c0NBQzNCLDhEQUFDRDs7OENBQ0MsOERBQUNLO29DQUFFSixXQUFVOzhDQUF3Qjs7Ozs7OzhDQUNyQyw4REFBQ0k7b0NBQUVKLFdBQVU7OENBQ1ZyTSxPQUFPa0UsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPNUI7O0FBRUE3RSxJQUFJc04sV0FBVyxHQUFHO0FBRWxCLCtEQUFldE4sR0FBR0EsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9NYXAudHN4P2IxNjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG4vKipcclxuICogTWFwIENvbXBvbmVudCAtIE1hcExpYnJlIEdMIEpTIG1hcCB3aXRoIGdsb2JlIHByb2plY3Rpb24gYW5kIG11bHRpLWxvY2F0aW9uIHN1cHBvcnRcclxuICogVXBkYXRlZCBmb3IgTmV4dC5qcyAtIG5vIGhhc2ggcm91dGluZywgdXNlcyBsb2NhbFN0b3JhZ2UgZm9yIG1hcCBzdGF0ZVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgbWFwbGlicmVnbCBmcm9tICdtYXBsaWJyZS1nbCdcclxuaW1wb3J0IHR5cGUgeyBNb3ZpZSwgRmlsdGVyU3RhdGUsIExvY2F0aW9uIH0gZnJvbSAnLi4vdHlwZXMnXHJcbmltcG9ydCB7IGZpbHRlck1vdmllcyB9IGZyb20gJy4uL3V0aWxzL2hlbHBlcnMnXHJcblxyXG5pbnRlcmZhY2UgTWFwUHJvcHMge1xyXG4gIHNlbGVjdGVkTW92aWU6IE1vdmllIHwgbnVsbFxyXG4gIG9uTW92aWVTZWxlY3Q6IChtb3ZpZTogTW92aWUgfCBudWxsKSA9PiB2b2lkXHJcbiAgc2VhcmNoUXVlcnk6IHN0cmluZ1xyXG4gIGZpbHRlcnM6IEZpbHRlclN0YXRlXHJcbiAgZm9jdXNlZE1vdmllSWQ/OiBzdHJpbmcgfCBudWxsXHJcbiAgb25DbGVhckZvY3VzPzogKCkgPT4gdm9pZFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcFJlZiB7XHJcbiAgc2hvd0FsbExvY2F0aW9uc0Zvck1vdmllOiAobW92aWU6IE1vdmllKSA9PiB2b2lkXHJcbiAgZmx5VG9Mb2NhdGlvbjogKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcikgPT4gdm9pZFxyXG59XHJcblxyXG5pbnRlcmZhY2UgR2VvSlNPTkZlYXR1cmUge1xyXG4gIHR5cGU6ICdGZWF0dXJlJ1xyXG4gIGlkOiBzdHJpbmdcclxuICBnZW9tZXRyeToge1xyXG4gICAgdHlwZTogJ1BvaW50JyB8ICdNdWx0aVBvaW50J1xyXG4gICAgY29vcmRpbmF0ZXM6IG51bWJlcltdIHwgbnVtYmVyW11bXVxyXG4gIH1cclxuICBwcm9wZXJ0aWVzOiB7XHJcbiAgICBtb3ZpZV9pZDogc3RyaW5nXHJcbiAgICB0bWRiX2lkOiBudW1iZXJcclxuICAgIHRpdGxlOiBzdHJpbmdcclxuICAgIHllYXI6IG51bWJlclxyXG4gICAgcG9zdGVyOiBzdHJpbmcgfCBudWxsXHJcbiAgICB0cmFpbGVyOiBzdHJpbmcgfCBudWxsXHJcbiAgICB0b3BfZ2VucmU6IHN0cmluZyB8IG51bGxcclxuICAgIGdlbnJlcz86IHN0cmluZ1tdXHJcbiAgICBzaG9ydF9kZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgICBpbWRiX3JhdGluZzogbnVtYmVyIHwgbnVsbFxyXG4gICAgbG9jYXRpb25zX2NvdW50OiBudW1iZXJcclxuICAgIGxvY2F0aW9uX25hbWVzOiBzdHJpbmdbXVxyXG4gICAgaGFzX3RpbWVsaW5lOiBib29sZWFuXHJcbiAgICBjZW50cm9pZD86IFtudW1iZXIsIG51bWJlcl1cclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IE1hcCA9IGZvcndhcmRSZWY8TWFwUmVmLCBNYXBQcm9wcz4oKHtcclxuICBzZWxlY3RlZE1vdmllLFxyXG4gIG9uTW92aWVTZWxlY3QsXHJcbiAgc2VhcmNoUXVlcnk6IF9zZWFyY2hRdWVyeSxcclxuICBmaWx0ZXJzLFxyXG4gIGZvY3VzZWRNb3ZpZUlkLFxyXG4gIG9uQ2xlYXJGb2N1cyxcclxufSwgcmVmKSA9PiB7XHJcbiAgY29uc3QgbWFwQ29udGFpbmVyID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxyXG4gIGNvbnN0IG1hcCA9IHVzZVJlZjxtYXBsaWJyZWdsLk1hcCB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgW21vdmllcywgc2V0TW92aWVzXSA9IHVzZVN0YXRlPE1vdmllW10+KFtdKVxyXG4gIGNvbnN0IFtnZW9qc29uRmVhdHVyZXMsIHNldEdlb2pzb25GZWF0dXJlc10gPSB1c2VTdGF0ZTxHZW9KU09ORmVhdHVyZVtdPihbXSlcclxuICBjb25zdCBpbml0aWFsaXplZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSlcclxuXHJcbiAgLy8gVHJhY2sgd2hpY2ggcG9zdGVyIGltYWdlcyBoYXZlIGJlZW4gbG9hZGVkIHRvIHByZXZlbnQgcmVkdW5kYW50IGxvYWRpbmdcclxuICBjb25zdCBsb2FkZWRJbWFnZXNSZWYgPSB1c2VSZWY8U2V0PHN0cmluZz4+KG5ldyBTZXQoKSlcclxuXHJcbiAgLy8gTG9hZGluZyBzdGF0ZSBmb3IgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nXHJcbiAgY29uc3QgW2xvYWRpbmdTdGF0ZSwgc2V0TG9hZGluZ1N0YXRlXSA9IHVzZVN0YXRlPHtcclxuICAgIGlzTG9hZGluZzogYm9vbGVhblxyXG4gICAgcHJvZ3Jlc3M6IG51bWJlclxyXG4gICAgc3RhZ2U6IHN0cmluZ1xyXG4gIH0+KHtcclxuICAgIGlzTG9hZGluZzogdHJ1ZSxcclxuICAgIHByb2dyZXNzOiAwLFxyXG4gICAgc3RhZ2U6ICdJbml0aWFsaXppbmcuLi4nXHJcbiAgfSlcclxuXHJcbiAgLy8gRXhwb3NlIG1ldGhvZHMgdG8gcGFyZW50IGNvbXBvbmVudFxyXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiAoe1xyXG4gICAgc2hvd0FsbExvY2F0aW9uc0Zvck1vdmllOiAobW92aWU6IE1vdmllKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBnZW9qc29uRmVhdHVyZXMuZmluZChmID0+IGYucHJvcGVydGllcy5tb3ZpZV9pZCA9PT0gbW92aWUubW92aWVfaWQpXHJcbiAgICAgIGlmIChmZWF0dXJlKSB7XHJcbiAgICAgICAgc2hvd0FsbExvY2F0aW9ucyhmZWF0dXJlKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZmx5VG9Mb2NhdGlvbjogKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcikgPT4ge1xyXG4gICAgICBpZiAobWFwLmN1cnJlbnQpIHtcclxuICAgICAgICBtYXAuY3VycmVudC5mbHlUbyh7XHJcbiAgICAgICAgICBjZW50ZXI6IFtsbmcsIGxhdF0sXHJcbiAgICAgICAgICB6b29tOiAxMixcclxuICAgICAgICAgIGR1cmF0aW9uOiAyMDAwLFxyXG4gICAgICAgICAgZXNzZW50aWFsOiB0cnVlXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pKVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IEdlb0pTT04gZmVhdHVyZSB0byBNb3ZpZSBvYmplY3RcclxuICAgKi9cclxuICBjb25zdCBjb252ZXJ0RmVhdHVyZVRvTW92aWUgPSAoZmVhdHVyZTogR2VvSlNPTkZlYXR1cmUpOiBNb3ZpZSA9PiB7XHJcbiAgICAvLyBFeHRyYWN0IGxvY2F0aW9ucyBmcm9tIGdlb21ldHJ5XHJcbiAgICBsZXQgbG9jYXRpb25zOiBMb2NhdGlvbltdID0gW11cclxuXHJcbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XHJcbiAgICAgIGNvbnN0IFtsbmcsIGxhdF0gPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIG51bWJlcltdXHJcbiAgICAgIGxvY2F0aW9ucyA9IFt7XHJcbiAgICAgICAgbGF0LFxyXG4gICAgICAgIGxuZyxcclxuICAgICAgICBjaXR5OiBmZWF0dXJlLnByb3BlcnRpZXMubG9jYXRpb25fbmFtZXNbMF0/LnNwbGl0KCcsJylbMF0gfHwgJ1Vua25vd24nLFxyXG4gICAgICAgIGNvdW50cnk6IGZlYXR1cmUucHJvcGVydGllcy5sb2NhdGlvbl9uYW1lc1swXT8uc3BsaXQoJywnKVsxXT8udHJpbSgpIHx8ICdVbmtub3duJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogZmVhdHVyZS5wcm9wZXJ0aWVzLmxvY2F0aW9uX25hbWVzWzBdPy5tYXRjaCgvXFwoKC4qPylcXCkvKT8uWzFdIHx8ICcnXHJcbiAgICAgIH1dXHJcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgICAgIGNvbnN0IGNvb3JkcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgYXMgbnVtYmVyW11bXVxyXG4gICAgICBsb2NhdGlvbnMgPSBjb29yZHMubWFwKChjb29yZCwgaWR4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgW2xuZywgbGF0XSA9IGNvb3JkXHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25OYW1lID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmxvY2F0aW9uX25hbWVzW2lkeF0gfHwgJ1Vua25vd24nXHJcbiAgICAgICAgY29uc3QgW2NpdHksIGNvdW50cnldID0gbG9jYXRpb25OYW1lLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpXHJcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBsb2NhdGlvbk5hbWUubWF0Y2goL1xcKCguKj8pXFwpLyk/LlsxXSB8fCAnJ1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsYXQsXHJcbiAgICAgICAgICBsbmcsXHJcbiAgICAgICAgICBjaXR5OiBjaXR5IHx8ICdVbmtub3duJyxcclxuICAgICAgICAgIGNvdW50cnk6IGNvdW50cnkgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb25cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbW92aWVfaWQ6IGZlYXR1cmUucHJvcGVydGllcy5tb3ZpZV9pZCxcclxuICAgICAgdGl0bGU6IGZlYXR1cmUucHJvcGVydGllcy50aXRsZSxcclxuICAgICAgeWVhcjogZmVhdHVyZS5wcm9wZXJ0aWVzLnllYXIsXHJcbiAgICAgIGltZGJfaWQ6IGZlYXR1cmUucHJvcGVydGllcy5tb3ZpZV9pZCxcclxuICAgICAgdG1kYl9pZDogU3RyaW5nKGZlYXR1cmUucHJvcGVydGllcy50bWRiX2lkKSxcclxuICAgICAgZ2VucmVzOiBmZWF0dXJlLnByb3BlcnRpZXMuZ2VucmVzIHx8IChmZWF0dXJlLnByb3BlcnRpZXMudG9wX2dlbnJlID8gW2ZlYXR1cmUucHJvcGVydGllcy50b3BfZ2VucmVdIDogW10pLFxyXG4gICAgICBwb3N0ZXI6IGZlYXR1cmUucHJvcGVydGllcy5wb3N0ZXIgfHwgdW5kZWZpbmVkLFxyXG4gICAgICB0cmFpbGVyOiBmZWF0dXJlLnByb3BlcnRpZXMudHJhaWxlciB8fCB1bmRlZmluZWQsXHJcbiAgICAgIGltZGJfcmF0aW5nOiBmZWF0dXJlLnByb3BlcnRpZXMuaW1kYl9yYXRpbmcgfHwgdW5kZWZpbmVkLFxyXG4gICAgICBsb2NhdGlvbnMsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIG1vdmllcyBkYXRhIGFuZCBHZW9KU09OIHdpdGggcHJvZ3Jlc3NpdmUgbG9hZGluZ1xyXG4gICAqL1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBMb2FkIEdlb0pTT04gZmVhdHVyZXNcclxuICAgICAgICBjb25zdCBnZW9qc29uUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2dlby9tb3ZpZXMuZ2VvanNvbicpXHJcbiAgICAgICAgY29uc3QgZ2VvanNvbkRhdGEgPSBhd2FpdCBnZW9qc29uUmVzcG9uc2UuanNvbigpXHJcblxyXG4gICAgICAgIC8vIFN0b3JlIGFsbCBmZWF0dXJlcyBmb3IgZmlsdGVyaW5nXHJcbiAgICAgICAgc2V0R2VvanNvbkZlYXR1cmVzKGdlb2pzb25EYXRhLmZlYXR1cmVzKVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBHZW9KU09OIGZlYXR1cmVzIHRvIE1vdmllIG9iamVjdHNcclxuICAgICAgICBjb25zdCBtb3ZpZXNGcm9tR2VvSlNPTjogTW92aWVbXSA9IGdlb2pzb25EYXRhLmZlYXR1cmVzLm1hcChjb252ZXJ0RmVhdHVyZVRvTW92aWUpXHJcbiAgICAgICAgc2V0TW92aWVzKG1vdmllc0Zyb21HZW9KU09OKVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBMb2FkZWQgJHtnZW9qc29uRGF0YS5mZWF0dXJlcy5sZW5ndGh9IG1vdmllcyBmb3IgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nYClcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBkYXRhOicsIGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2FkRGF0YSgpXHJcbiAgfSwgW10pXHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgbWFwXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWFwQ29udGFpbmVyLmN1cnJlbnQgfHwgbWFwLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgIG1hcC5jdXJyZW50ID0gbmV3IG1hcGxpYnJlZ2wuTWFwKHtcclxuICAgICAgY29udGFpbmVyOiBtYXBDb250YWluZXIuY3VycmVudCxcclxuICAgICAgLy8gVXNlIE1hcFRpbGVyIGJhc2ljIHN0eWxlIC0gZnJlZSB0aWVyLCB3b3JrcyB3aXRoIGdsb2JlXHJcbiAgICAgIHN0eWxlOiAnaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL21hcHMvYmFzaWMtdjIvc3R5bGUuanNvbj9rZXk9Z2V0X3lvdXJfb3duX09wSWk5WlVMTkh6ckVTdjZUMnZMJyxcclxuICAgICAgem9vbTogMi44OCxcclxuICAgICAgY2VudGVyOiBbMC4zNSwgNDNdLCAvLyBDZW50ZXJlZCBvbiBFdXJvcGVcclxuICAgICAgLy8gaGFzaDogdHJ1ZSAvLyBSZW1vdmVkIGZvciBOZXh0LmpzIC0gdXNpbmcgbG9jYWxTdG9yYWdlIGZvciBjbGVhbiBVUkxzXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIEdsb2JlIHJvdGF0aW9uIGFuaW1hdGlvblxyXG4gICAgbGV0IGlzVXNlckludGVyYWN0aW5nID0gZmFsc2VcclxuICAgIGxldCByb3RhdGlvbkFuaW1hdGlvbjogbnVtYmVyIHwgbnVsbCA9IG51bGxcclxuXHJcbiAgICBjb25zdCBzdGFydFJvdGF0aW9uID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIW1hcC5jdXJyZW50IHx8IGlzVXNlckludGVyYWN0aW5nKSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IHJvdGF0ZUNhbWVyYSA9IChfdGltZXN0YW1wOiBudW1iZXIpID0+IHtcclxuICAgICAgICBpZiAoIW1hcC5jdXJyZW50IHx8IGlzVXNlckludGVyYWN0aW5nKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy8gUm90YXRlIDM2MCBkZWdyZWVzIG92ZXIgMiBtaW51dGVzICgxMjAgc2Vjb25kcylcclxuICAgICAgICBjb25zdCBzZWNvbmRzUGVyUmV2b2x1dGlvbiA9IDcyMFxyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5jdXJyZW50LmdldENlbnRlcigpXHJcbiAgICAgICAgY2VudGVyLmxuZyA9IChjZW50ZXIubG5nICsgKDM2MCAvIHNlY29uZHNQZXJSZXZvbHV0aW9uKSAqICgxLzYwKSkgJSAzNjBcclxuICAgICAgICBtYXAuY3VycmVudC5zZXRDZW50ZXIoY2VudGVyKVxyXG5cclxuICAgICAgICByb3RhdGlvbkFuaW1hdGlvbiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyb3RhdGVDYW1lcmEpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJvdGF0aW9uQW5pbWF0aW9uID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJvdGF0ZUNhbWVyYSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdG9wUm90YXRpb24gPSAoKSA9PiB7XHJcbiAgICAgIGlzVXNlckludGVyYWN0aW5nID0gdHJ1ZVxyXG4gICAgICBpZiAocm90YXRpb25BbmltYXRpb24gIT09IG51bGwpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyb3RhdGlvbkFuaW1hdGlvbilcclxuICAgICAgICByb3RhdGlvbkFuaW1hdGlvbiA9IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1hcC5jdXJyZW50Lm9uKCdzdHlsZS5sb2FkJywgKCkgPT4ge1xyXG4gICAgICBpZiAobWFwLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBTZXQgcHJvamVjdGlvbiB0byBnbG9iZVxyXG4gICAgICAgIChtYXAuY3VycmVudCBhcyBhbnkpLnNldFByb2plY3Rpb24oe1xyXG4gICAgICAgICAgdHlwZTogJ2dsb2JlJyxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIG1hcCBwb3NpdGlvbiBmcm9tIGxvY2FsU3RvcmFnZSAoY2xlYW4gVVJMcylcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIGNvbnN0IHNhdmVkU3RhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2luZW1hcF92aWV3JylcclxuICAgICAgICAgIGlmIChzYXZlZFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgeyBsYXQsIGxuZywgem9vbSB9ID0gSlNPTi5wYXJzZShzYXZlZFN0YXRlKVxyXG4gICAgICAgICAgICAgIG1hcC5jdXJyZW50LnNldENlbnRlcihbbG5nLCBsYXRdKVxyXG4gICAgICAgICAgICAgIG1hcC5jdXJyZW50LnNldFpvb20oem9vbSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIC8vIElnbm9yZSBpbnZhbGlkIHN0b3JlZCBzdGF0ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGFydCByb3RhdGlvbiBhZnRlciBtYXAgbG9hZHNcclxuICAgICAgICBzZXRUaW1lb3V0KHN0YXJ0Um90YXRpb24sIDEwMDApXHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gU2F2ZSBtYXAgcG9zaXRpb24gdG8gbG9jYWxTdG9yYWdlIG9uIG1vdmVtZW50IChkZWJvdW5jZWQpXHJcbiAgICBsZXQgc2F2ZVRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGxcclxuICAgIGNvbnN0IHNhdmVNYXBTdGF0ZSA9ICgpID0+IHtcclxuICAgICAgaWYgKCFtYXAuY3VycmVudCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXHJcbiAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5jdXJyZW50LmdldENlbnRlcigpXHJcbiAgICAgIGNvbnN0IHpvb20gPSBtYXAuY3VycmVudC5nZXRab29tKClcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NpbmVtYXBfdmlldycsIEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICBsYXQ6IGNlbnRlci5sYXQsXHJcbiAgICAgICAgbG5nOiBjZW50ZXIubG5nLFxyXG4gICAgICAgIHpvb206IHpvb21cclxuICAgICAgfSkpXHJcbiAgICB9XHJcblxyXG4gICAgbWFwLmN1cnJlbnQub24oJ21vdmVlbmQnLCAoKSA9PiB7XHJcbiAgICAgIGlmIChzYXZlVGltZW91dCkgY2xlYXJUaW1lb3V0KHNhdmVUaW1lb3V0KVxyXG4gICAgICBzYXZlVGltZW91dCA9IHNldFRpbWVvdXQoc2F2ZU1hcFN0YXRlLCA1MDApXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFN0b3Agcm90YXRpb24gb24gYW55IHVzZXIgaW50ZXJhY3Rpb25cclxuICAgIG1hcC5jdXJyZW50Lm9uKCdtb3VzZWRvd24nLCBzdG9wUm90YXRpb24pXHJcbiAgICBtYXAuY3VycmVudC5vbigndG91Y2hzdGFydCcsIHN0b3BSb3RhdGlvbilcclxuICAgIG1hcC5jdXJyZW50Lm9uKCd3aGVlbCcsIHN0b3BSb3RhdGlvbilcclxuICAgIG1hcC5jdXJyZW50Lm9uKCdkcmFnc3RhcnQnLCBzdG9wUm90YXRpb24pXHJcblxyXG4gICAgLy8gQWRkIG5hdmlnYXRpb24gY29udHJvbHNcclxuICAgIG1hcC5jdXJyZW50LmFkZENvbnRyb2wobmV3IG1hcGxpYnJlZ2wuTmF2aWdhdGlvbkNvbnRyb2woKSwgJ2JvdHRvbS1yaWdodCcpXHJcbiAgICBtYXAuY3VycmVudC5hZGRDb250cm9sKG5ldyBtYXBsaWJyZWdsLkZ1bGxzY3JlZW5Db250cm9sKCksICdib3R0b20tcmlnaHQnKVxyXG5cclxuICAgIC8vIERvbid0IGFkZCB6b29tIGxpc3RlbmVyIGhlcmUgLSBpdCBjYXVzZXMgaXNzdWVzIHdpdGggdGlsZSBsb2FkaW5nXHJcbiAgICAvLyBXZSdsbCBoYW5kbGUgaXQgZGlmZmVyZW50bHlcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAobWFwLmN1cnJlbnQpIHtcclxuICAgICAgICBtYXAuY3VycmVudC5yZW1vdmUoKVxyXG4gICAgICAgIG1hcC5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pXHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgYW5kIGNyZWF0ZSBwb3N0ZXIgaW1hZ2UgaWNvbiB3aXRoIG1vdmllIGJhZGdlXHJcbiAgICovXHJcbiAgY29uc3QgY3JlYXRlUG9zdGVySWNvbiA9IGFzeW5jIChwb3N0ZXJQYXRoOiBzdHJpbmcgfCBudWxsLCBfbW92aWVJZDogc3RyaW5nLCBfaXNNdWx0aUxvY2F0aW9uOiBib29sZWFuKTogUHJvbWlzZTx7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyOyBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB9PiA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgY29uc3Qgc2l6ZSA9IDYwIC8vIENvbnNpc3RlbnQgc2l6ZSBmb3IgYWxsIG1hcmtlcnNcclxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgY2FudmFzLndpZHRoID0gc2l6ZVxyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gc2l6ZVxyXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSFcclxuXHJcbiAgICAgIC8vIElmIG5vIHBvc3RlciwgY3JlYXRlIGZhbGxiYWNrIGljb25cclxuICAgICAgaWYgKCFwb3N0ZXJQYXRoKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGNpcmN1bGFyIGJhY2tncm91bmRcclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHguYXJjKHNpemUgLyAyLCBzaXplIC8gMiwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzNCODJGNidcclxuICAgICAgICBjdHguZmlsbCgpXHJcblxyXG4gICAgICAgIC8vIFdoaXRlIGJvcmRlclxyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjRkZGRkZGJ1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAzXHJcbiAgICAgICAgY3R4LnN0cm9rZSgpXHJcblxyXG4gICAgICAgIC8vIEZpbG0gaWNvblxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI0ZGRkZGRidcclxuICAgICAgICBjdHguZm9udCA9ICdib2xkIDI0cHggQXJpYWwnXHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInXHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnXHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KCfwn46sJywgc2l6ZSAvIDIsIHNpemUgLyAyKVxyXG5cclxuICAgICAgICByZXNvbHZlKHsgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSwgZGF0YTogY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLCBzaXplKS5kYXRhIH0pXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExvYWQgcG9zdGVyIGltYWdlXHJcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXHJcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnXHJcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGNpcmN1bGFyIGNsaXBwaW5nIG1hc2tcclxuICAgICAgICBjdHguc2F2ZSgpXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgY3R4LmFyYyhzaXplIC8gMiwgc2l6ZSAvIDIsIHNpemUgLyAyLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgICBjdHguY2xpcCgpXHJcblxyXG4gICAgICAgIC8vIERyYXcgcG9zdGVyIChjZW50ZXJlZCBhbmQgc2NhbGVkKVxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBzaXplLCBzaXplKVxyXG4gICAgICAgIGN0eC5yZXN0b3JlKClcclxuXHJcbiAgICAgICAgLy8gV2hpdGUgYm9yZGVyIGFyb3VuZCBjaXJjbGVcclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHguYXJjKHNpemUgLyAyLCBzaXplIC8gMiwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjMTBiZTUwZmYnXHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDNcclxuICAgICAgICBjdHguc3Ryb2tlKClcclxuXHJcbiAgICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUsIGRhdGE6IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZSwgc2l6ZSkuZGF0YSB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAvLyBGYWxsYmFjayBvbiBlcnJvciAtIGNpcmN1bGFyIGljb25cclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHguYXJjKHNpemUgLyAyLCBzaXplIC8gMiwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzNCODJGNidcclxuICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNGRkZGRkYnXHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDNcclxuICAgICAgICBjdHguc3Ryb2tlKClcclxuXHJcbiAgICAgICAgLy8gRmlsbSBpY29uIGZhbGxiYWNrXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJ1xyXG4gICAgICAgIGN0eC5mb250ID0gJ2JvbGQgMjBweCBBcmlhbCdcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcidcclxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSdcclxuICAgICAgICBjdHguZmlsbFRleHQoJ/CfjqwnLCBzaXplIC8gMiwgc2l6ZSAvIDIpXHJcblxyXG4gICAgICAgIHJlc29sdmUoeyB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplLCBkYXRhOiBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUsIHNpemUpLmRhdGEgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXNlIHRoZSBmdWxsIHBvc3RlciBVUkwgZnJvbSB0aGUgZGF0YVxyXG4gICAgICBpbWcuc3JjID0gcG9zdGVyUGF0aFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgYWxsIGxvY2F0aW9ucyBmb3IgYSBtb3ZpZVxyXG4gICAqL1xyXG4gIGNvbnN0IHNob3dBbGxMb2NhdGlvbnMgPSAoZmVhdHVyZTogR2VvSlNPTkZlYXR1cmUpID0+IHtcclxuICAgIGlmICghbWFwLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCdcclxuICAgICAgPyBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIG51bWJlcltdW11cclxuICAgICAgOiBbZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyBhcyBudW1iZXJbXV1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYm91bmRzXHJcbiAgICBjb25zdCBib3VuZHMgPSBuZXcgbWFwbGlicmVnbC5MbmdMYXRCb3VuZHMoKVxyXG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaChjb29yZCA9PiBib3VuZHMuZXh0ZW5kKGNvb3JkIGFzIFtudW1iZXIsIG51bWJlcl0pKVxyXG5cclxuICAgIC8vIEZpdCBtYXAgdG8gYm91bmRzXHJcbiAgICBtYXAuY3VycmVudC5maXRCb3VuZHMoYm91bmRzLCB7XHJcbiAgICAgIHBhZGRpbmc6IDEwMCxcclxuICAgICAgbWF4Wm9vbTogMTAsXHJcbiAgICAgIGR1cmF0aW9uOiAxMDAwXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFJlbW92ZSBleGlzdGluZyBjb25uZWN0aW5nIGxpbmVcclxuICAgIGlmIChtYXAuY3VycmVudC5nZXRMYXllcignY29ubmVjdGluZy1saW5lJykpIHtcclxuICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlTGF5ZXIoJ2Nvbm5lY3RpbmctbGluZScpXHJcbiAgICB9XHJcbiAgICBpZiAobWFwLmN1cnJlbnQuZ2V0U291cmNlKCdjb25uZWN0aW5nLWxpbmUnKSkge1xyXG4gICAgICBtYXAuY3VycmVudC5yZW1vdmVTb3VyY2UoJ2Nvbm5lY3RpbmctbGluZScpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBjb25uZWN0aW5nIHBvbHlsaW5lIGZvciBtdWx0aS1sb2NhdGlvbiBtb3ZpZXNcclxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIG1hcC5jdXJyZW50LmFkZFNvdXJjZSgnY29ubmVjdGluZy1saW5lJywge1xyXG4gICAgICAgIHR5cGU6ICdnZW9qc29uJyxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgICBnZW9tZXRyeToge1xyXG4gICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXHJcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcHJvcGVydGllczoge31cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBtYXAuY3VycmVudC5hZGRMYXllcih7XHJcbiAgICAgICAgaWQ6ICdjb25uZWN0aW5nLWxpbmUnLFxyXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICBzb3VyY2U6ICdjb25uZWN0aW5nLWxpbmUnLFxyXG4gICAgICAgIHBhaW50OiB7XHJcbiAgICAgICAgICAnbGluZS1jb2xvcic6ICcjRjU5RTBCJywgLy8gVmlicmFudCBhbWJlciBjb2xvclxyXG4gICAgICAgICAgJ2xpbmUtd2lkdGgnOiA0LFxyXG4gICAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IDAuOSxcclxuICAgICAgICAgICdsaW5lLWJsdXInOiAxXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gS2VlcCBsaW5lIHZpc2libGUgcGVybWFuZW50bHlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBtb3ZpZSBtYXJrZXJzIGZyb20gR2VvSlNPTiAtIElOSVRJQUwgTE9BRCBPTkxZXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWFwLmN1cnJlbnQgfHwgZ2VvanNvbkZlYXR1cmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXHJcblxyXG4gICAgLy8gT25seSBydW4gdGhpcyBlZmZlY3Qgb25jZSB3aGVuIGRhdGEgaXMgZmlyc3QgbG9hZGVkXHJcbiAgICBpZiAoaW5pdGlhbGl6ZWRSZWYuY3VycmVudCB8fCBtYXAuY3VycmVudC5nZXRTb3VyY2UoJ21vdmllcycpKSByZXR1cm5cclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplTWFya2VycygpIHtcclxuICAgICAgaWYgKCFtYXAuY3VycmVudCkgcmV0dXJuXHJcblxyXG4gICAgICAvLyBMb2FkIEFMTCBwb3N0ZXJzIEJFRk9SRSBhZGRpbmcgbWFwIGxheWVyIChwcmV2ZW50cyB3YXJuaW5ncylcclxuICAgICAgY29uc3QgQkFUQ0hfU0laRSA9IDIwXHJcbiAgICAgIGxldCBsb2FkZWRDb3VudCA9IDBcclxuICAgICAgY29uc3QgYWxsRmVhdHVyZXMgPSBnZW9qc29uRmVhdHVyZXNcclxuXHJcbiAgICAgIC8vIE9ubHkgc2hvdyBsb2FkaW5nIG9uIGluaXRpYWwgc2V0dXAsIG5vdCBvbiBTdHJpY3RNb2RlIHJlLW1vdW50c1xyXG4gICAgICBpZiAoIWluaXRpYWxpemVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzZXRMb2FkaW5nU3RhdGUoe1xyXG4gICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgICAgICAgcHJvZ3Jlc3M6IDkwLFxyXG4gICAgICAgICAgc3RhZ2U6IGBMb2FkaW5nIHBvc3RlcnMuLi4gMC8ke2FsbEZlYXR1cmVzLmxlbmd0aH1gXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBwb3N0ZXJzIGluIGJhdGNoZXMgYW5kIGF3YWl0IGNvbXBsZXRpb25cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxGZWF0dXJlcy5sZW5ndGg7IGkgKz0gQkFUQ0hfU0laRSkge1xyXG4gICAgICAgIGNvbnN0IGJhdGNoID0gYWxsRmVhdHVyZXMuc2xpY2UoaSwgaSArIEJBVENIX1NJWkUpXHJcblxyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgICAgYmF0Y2gubWFwKGFzeW5jIChmZWF0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmllSWQgPSBmZWF0dXJlLnByb3BlcnRpZXMubW92aWVfaWRcclxuICAgICAgICAgICAgY29uc3QgcG9zdGVyUGF0aCA9IGZlYXR1cmUucHJvcGVydGllcy5wb3N0ZXJcclxuICAgICAgICAgICAgY29uc3QgaXNNdWx0aUxvY2F0aW9uID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmxvY2F0aW9uc19jb3VudCA+IDFcclxuICAgICAgICAgICAgY29uc3QgaWNvbk5hbWUgPSBgcG9zdGVyLSR7bW92aWVJZH1gXHJcblxyXG4gICAgICAgICAgICBpZiAoIW1hcC5jdXJyZW50IS5oYXNJbWFnZShpY29uTmFtZSkpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdGVySWNvbiA9IGF3YWl0IGNyZWF0ZVBvc3Rlckljb24ocG9zdGVyUGF0aCwgbW92aWVJZCwgaXNNdWx0aUxvY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgbWFwLmN1cnJlbnQhLmFkZEltYWdlKGljb25OYW1lLCBwb3N0ZXJJY29uKVxyXG4gICAgICAgICAgICAgICAgbG9hZGVkSW1hZ2VzUmVmLmN1cnJlbnQuYWRkKGljb25OYW1lKSAvLyBNYXJrIGFzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgbG9hZGVkQ291bnQrK1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gYWRkIHBvc3RlciBpY29uIGZvciAke21vdmllSWR9OmAsIGVycm9yKVxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGZhbGxiYWNrIGljb24gb24gZXJyb3JcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrSWNvbiA9IGF3YWl0IGNyZWF0ZVBvc3Rlckljb24obnVsbCwgbW92aWVJZCwgaXNNdWx0aUxvY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgbWFwLmN1cnJlbnQhLmFkZEltYWdlKGljb25OYW1lLCBmYWxsYmFja0ljb24pXHJcbiAgICAgICAgICAgICAgICBsb2FkZWRJbWFnZXNSZWYuY3VycmVudC5hZGQoaWNvbk5hbWUpIC8vIE1hcmsgYXMgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICBsb2FkZWRDb3VudCsrXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGxvYWRlZENvdW50KytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBhZnRlciBlYWNoIGJhdGNoXHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKChsb2FkZWRDb3VudCAvIGFsbEZlYXR1cmVzLmxlbmd0aCkgKiAxMDApXHJcbiAgICAgICAgc2V0TG9hZGluZ1N0YXRlKHtcclxuICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcclxuICAgICAgICAgIHByb2dyZXNzOiA5MCArIChwcm9ncmVzcyAqIDAuMDkpLCAvLyA5MC05OSUgcmFuZ2VcclxuICAgICAgICAgIHN0YWdlOiBgTG9hZGluZyBwb3N0ZXJzLi4uICR7bG9hZGVkQ291bnR9LyR7YWxsRmVhdHVyZXMubGVuZ3RofWBcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTaG93IHJlbmRlcmluZyBzdGFnZSBvbmx5IG9uIGluaXRpYWwgc2V0dXBcclxuICAgICAgaWYgKCFpbml0aWFsaXplZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc2V0TG9hZGluZ1N0YXRlKHtcclxuICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcclxuICAgICAgICAgIHByb2dyZXNzOiA5OSxcclxuICAgICAgICAgIHN0YWdlOiAnUmVuZGVyaW5nIG1hcmtlcnMuLi4nXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBNdWx0aVBvaW50IGZlYXR1cmVzIGludG8gaW5kaXZpZHVhbCBQb2ludCBmZWF0dXJlcyBmb3IgZWFjaCBsb2NhdGlvblxyXG4gICAgICBjb25zdCBkaXNwbGF5RmVhdHVyZXM6IGFueVtdID0gW11cclxuXHJcbiAgICAgIGFsbEZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzZXBhcmF0ZSBmZWF0dXJlIGZvciBlYWNoIGxvY2F0aW9uXHJcbiAgICAgICAgICBjb25zdCBjb29yZHMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIG51bWJlcltdW11cclxuICAgICAgICAgIGNvb3Jkcy5mb3JFYWNoKChjb29yZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgZGlzcGxheUZlYXR1cmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgIC4uLmZlYXR1cmUsXHJcbiAgICAgICAgICAgICAgaWQ6IGAke2ZlYXR1cmUuaWR9LWxvYy0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdQb2ludCcgYXMgY29uc3QsXHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBTaW5nbGUgbG9jYXRpb24gLSBrZWVwIGFzIGlzXHJcbiAgICAgICAgICBkaXNwbGF5RmVhdHVyZXMucHVzaChmZWF0dXJlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBHZW9KU09OIGZvciBkaXNwbGF5XHJcbiAgICAgIGNvbnN0IGdlb2pzb246IEdlb0pTT04uRmVhdHVyZUNvbGxlY3Rpb24gPSB7XHJcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICAgICAgICBmZWF0dXJlczogZGlzcGxheUZlYXR1cmVzIGFzIGFueVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgc291cmNlIC0gRElTQUJMRSBjbHVzdGVyaW5nIHNvIG1hcmtlcnMgc3RheSB2aXNpYmxlXHJcbiAgICAgIG1hcC5jdXJyZW50IS5hZGRTb3VyY2UoJ21vdmllcycsIHtcclxuICAgICAgICB0eXBlOiAnZ2VvanNvbicsXHJcbiAgICAgICAgZGF0YTogZ2VvanNvbixcclxuICAgICAgICAvLyBDbHVzdGVyaW5nIGRpc2FibGVkIC0gd2Ugd2FudCB0byBzZWUgYWxsIG1hcmtlcnNcclxuICAgICAgICBjbHVzdGVyOiBmYWxzZSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIEFkZCBhbGwgbW92aWUgbWFya2VycyBsYXllciAobm93IGVhY2ggbWFya2VyIHJlcHJlc2VudHMgb25lIGFjdHVhbCBsb2NhdGlvbilcclxuICAgICAgbWFwLmN1cnJlbnQhLmFkZExheWVyKHtcclxuICAgICAgICBpZDogJ21vdmllLW1hcmtlcnMnLFxyXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxyXG4gICAgICAgIHNvdXJjZTogJ21vdmllcycsXHJcbiAgICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgICAnaWNvbi1pbWFnZSc6IFsnY29uY2F0JywgJ3Bvc3Rlci0nLCBbJ2dldCcsICdtb3ZpZV9pZCddXSxcclxuICAgICAgICAgICdpY29uLXNpemUnOiAwLjcsXHJcbiAgICAgICAgICAnaWNvbi1hbGxvdy1vdmVybGFwJzogdHJ1ZSxcclxuICAgICAgICAgICd0ZXh0LWZpZWxkJzogWydnZXQnLCAndGl0bGUnXSxcclxuICAgICAgICAgICd0ZXh0LWZvbnQnOiBbJ09wZW4gU2FucyBCb2xkJywgJ0FyaWFsIFVuaWNvZGUgTVMgQm9sZCddLFxyXG4gICAgICAgICAgJ3RleHQtc2l6ZSc6IDE0LFxyXG4gICAgICAgICAgJ3RleHQtb2Zmc2V0JzogWzAsIDIuOF0sXHJcbiAgICAgICAgICAndGV4dC1hbmNob3InOiAndG9wJyxcclxuICAgICAgICAgICd0ZXh0LW1heC13aWR0aCc6IDEyLFxyXG4gICAgICAgICAgJ3RleHQtYWxsb3ctb3ZlcmxhcCc6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYWludDoge1xyXG4gICAgICAgICAgJ3RleHQtY29sb3InOiAnIzEwYmU1MGZmJyxcclxuICAgICAgICAgICd0ZXh0LWhhbG8tY29sb3InOiAnIzFGMjkzNycsXHJcbiAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMi41LFxyXG4gICAgICAgICAgJ3RleHQtaGFsby1ibHVyJzogMVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIEFsbCBkb25lIC0gaGlkZSBsb2FkaW5nIHNjcmVlbiBvbmx5IG9uIGluaXRpYWwgc2V0dXBcclxuICAgICAgaWYgKCFpbml0aWFsaXplZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBzZXRMb2FkaW5nU3RhdGUoeyBpc0xvYWRpbmc6IGZhbHNlLCBwcm9ncmVzczogMTAwLCBzdGFnZTogJ0NvbXBsZXRlJyB9KVxyXG4gICAgICAgICAgaW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICB9LCAzMDApIC8vIFNtYWxsIGRlbGF5IGZvciBzbW9vdGggdHJhbnNpdGlvblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgdW5pZmllZCBjbGljayBoYW5kbGVyIGZvciBhbGwgbW92aWUgbWFya2Vyc1xyXG4gICAgICBjb25zdCBoYW5kbGVNYXJrZXJDbGljayA9IChlOiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoIWUuZmVhdHVyZXMgfHwgZS5mZWF0dXJlcy5sZW5ndGggPT09IDApIHJldHVyblxyXG5cclxuICAgICAgICBjb25zdCBmZWF0dXJlID0gZS5mZWF0dXJlc1swXVxyXG5cclxuICAgICAgICAvLyBUcnkgdG8gZmluZCBpbiBnZW9qc29uRmVhdHVyZXMgYnkgbW92aWVfaWRcclxuICAgICAgICBjb25zdCBmZWF0dXJlQnlNb3ZpZUlkID0gZ2VvanNvbkZlYXR1cmVzLmZpbmQoZiA9PiBmLnByb3BlcnRpZXMubW92aWVfaWQgPT09IGZlYXR1cmUucHJvcGVydGllcy5tb3ZpZV9pZClcclxuXHJcbiAgICAgICAgaWYgKGZlYXR1cmVCeU1vdmllSWQpIHtcclxuICAgICAgICAgIGNvbnN0IG1vdmllRnJvbUZlYXR1cmUgPSBjb252ZXJ0RmVhdHVyZVRvTW92aWUoZmVhdHVyZUJ5TW92aWVJZClcclxuICAgICAgICAgIG9uTW92aWVTZWxlY3QobW92aWVGcm9tRmVhdHVyZSlcclxuICAgICAgICAgIC8vIFNob3cgYWxsIGxvY2F0aW9ucyBmb3IgbXVsdGktbG9jYXRpb24gbW92aWVzXHJcbiAgICAgICAgICBpZiAoZmVhdHVyZUJ5TW92aWVJZC5wcm9wZXJ0aWVzLmxvY2F0aW9uc19jb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzaG93QWxsTG9jYXRpb25zKGZlYXR1cmVCeU1vdmllSWQpLCA1MDApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIExhc3QgcmVzb3J0OiBjcmVhdGUgYSBtaW5pbWFsIG1vdmllIG9iamVjdFxyXG4gICAgICAgICAgY29uc3QgbW92aWVGcm9tQ2xpY2sgPSB7XHJcbiAgICAgICAgICAgIG1vdmllX2lkOiBmZWF0dXJlLnByb3BlcnRpZXMubW92aWVfaWQsXHJcbiAgICAgICAgICAgIHRpdGxlOiBmZWF0dXJlLnByb3BlcnRpZXMudGl0bGUsXHJcbiAgICAgICAgICAgIHllYXI6IGZlYXR1cmUucHJvcGVydGllcy55ZWFyLFxyXG4gICAgICAgICAgICBpbWRiX2lkOiBmZWF0dXJlLnByb3BlcnRpZXMubW92aWVfaWQsXHJcbiAgICAgICAgICAgIHRtZGJfaWQ6IFN0cmluZyhmZWF0dXJlLnByb3BlcnRpZXMudG1kYl9pZCksXHJcbiAgICAgICAgICAgIGdlbnJlczogZmVhdHVyZS5wcm9wZXJ0aWVzLmdlbnJlcyB8fCAoZmVhdHVyZS5wcm9wZXJ0aWVzLnRvcF9nZW5yZSA/IFtmZWF0dXJlLnByb3BlcnRpZXMudG9wX2dlbnJlXSA6IFtdKSxcclxuICAgICAgICAgICAgcG9zdGVyOiBmZWF0dXJlLnByb3BlcnRpZXMucG9zdGVyIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdHJhaWxlcjogZmVhdHVyZS5wcm9wZXJ0aWVzLnRyYWlsZXIgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBpbWRiX3JhdGluZzogZmVhdHVyZS5wcm9wZXJ0aWVzLmltZGJfcmF0aW5nIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbG9jYXRpb25zOiBbe1xyXG4gICAgICAgICAgICAgIGxhdDogMCxcclxuICAgICAgICAgICAgICBsbmc6IDAsXHJcbiAgICAgICAgICAgICAgY2l0eTogJ1Vua25vd24nLFxyXG4gICAgICAgICAgICAgIGNvdW50cnk6ICdVbmtub3duJyxcclxuICAgICAgICAgICAgfV0sIC8vIE1pbmltYWwgbG9jYXRpb24gdG8gcHJldmVudCBjcmFzaFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb25Nb3ZpZVNlbGVjdChtb3ZpZUZyb21DbGljayBhcyBNb3ZpZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1hcC5jdXJyZW50IS5vbignY2xpY2snLCAnbW92aWUtbWFya2VycycsIGhhbmRsZU1hcmtlckNsaWNrKVxyXG5cclxuICAgICAgLy8gQ2xlYXIgZm9jdXMgd2hlbiBjbGlja2luZyBvbiBlbXB0eSBtYXAgKG5vdCBvbiBtYXJrZXJzKVxyXG4gICAgICBjb25zdCBoYW5kbGVNYXBDbGljayA9IChlOiBhbnkpID0+IHtcclxuICAgICAgICAvLyBPbmx5IGNsZWFyIGZvY3VzIGlmIGNsaWNraW5nIG9uIGVtcHR5IHNwYWNlIChub3Qgb24gbWFya2VycylcclxuICAgICAgICBpZiAoIWUuZmVhdHVyZXMgfHwgZS5mZWF0dXJlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGlmIChmb2N1c2VkTW92aWVJZCAmJiBvbkNsZWFyRm9jdXMpIHtcclxuICAgICAgICAgICAgb25DbGVhckZvY3VzKClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1hcC5jdXJyZW50IS5vbignY2xpY2snLCBoYW5kbGVNYXBDbGljaylcclxuXHJcbiAgICAgIC8vIENoYW5nZSBjdXJzb3Igb24gaG92ZXJcclxuICAgICAgbWFwLmN1cnJlbnQhLm9uKCdtb3VzZWVudGVyJywgJ21vdmllLW1hcmtlcnMnLCAoKSA9PiB7XHJcbiAgICAgICAgbWFwLmN1cnJlbnQhLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJ1xyXG4gICAgICB9KVxyXG4gICAgICBtYXAuY3VycmVudCEub24oJ21vdXNlbGVhdmUnLCAnbW92aWUtbWFya2VycycsICgpID0+IHtcclxuICAgICAgICBtYXAuY3VycmVudCEuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJydcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBXYWl0IGZvciBzdHlsZSB0byBiZSBsb2FkZWRcclxuICAgIGlmICghbWFwLmN1cnJlbnQuaXNTdHlsZUxvYWRlZCgpKSB7XHJcbiAgICAgIG1hcC5jdXJyZW50Lm9uKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgIGluaXRpYWxpemVNYXJrZXJzKClcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluaXRpYWxpemVNYXJrZXJzKClcclxuICAgIH1cclxuICB9LCBbZ2VvanNvbkZlYXR1cmVzXSkgLy8gT25seSBkZXBlbmQgb24gZ2VvanNvbkZlYXR1cmVzIC0gcnVuIG9uY2Ugd2hlbiBkYXRhIGxvYWRzXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB2aXNpYmxlIG1hcmtlcnMgYmFzZWQgb24gZmlsdGVycyBhbmQgZm9jdXMgLSBOTyBSRUJVSUxESU5HXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbWFwLmN1cnJlbnQgfHwgIW1hcC5jdXJyZW50LmdldFNvdXJjZSgnbW92aWVzJykpIHJldHVyblxyXG5cclxuICAgIGxldCBmaWx0ZXJlZEZlYXR1cmVzOiBHZW9KU09ORmVhdHVyZVtdXHJcblxyXG4gICAgLy8gSWYgYSBtb3ZpZSBpcyBmb2N1c2VkLCBPTkxZIHNob3cgdGhhdCBtb3ZpZSdzIG1hcmtlcnMgKGlnbm9yZSBhbGwgb3RoZXIgZmlsdGVycylcclxuICAgIGlmIChmb2N1c2VkTW92aWVJZCkge1xyXG4gICAgICBmaWx0ZXJlZEZlYXR1cmVzID0gZ2VvanNvbkZlYXR1cmVzLmZpbHRlcihmID0+IGYucHJvcGVydGllcy5tb3ZpZV9pZCA9PT0gZm9jdXNlZE1vdmllSWQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBOb3JtYWwgbW9kZTogYXBwbHkgc2VhcmNoIGFuZCBmaWx0ZXIgbG9naWNcclxuICAgICAgY29uc3QgZmlsdGVyZWRNb3ZpZXMgPSBmaWx0ZXJNb3ZpZXMobW92aWVzLCBmaWx0ZXJzKVxyXG4gICAgICBjb25zdCBmaWx0ZXJlZElkcyA9IG5ldyBTZXQoZmlsdGVyZWRNb3ZpZXMubWFwKG0gPT4gbS5tb3ZpZV9pZCkpXHJcblxyXG4gICAgICBmaWx0ZXJlZEZlYXR1cmVzID0gbW92aWVzLmxlbmd0aCA+IDBcclxuICAgICAgICA/IGdlb2pzb25GZWF0dXJlcy5maWx0ZXIoZiA9PiBmaWx0ZXJlZElkcy5oYXMoZi5wcm9wZXJ0aWVzLm1vdmllX2lkKSlcclxuICAgICAgICA6IGdlb2pzb25GZWF0dXJlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgTXVsdGlQb2ludCBmZWF0dXJlcyBpbnRvIGluZGl2aWR1YWwgUG9pbnQgZmVhdHVyZXNcclxuICAgIGNvbnN0IGRpc3BsYXlGZWF0dXJlczogYW55W10gPSBbXVxyXG5cclxuICAgIGZpbHRlcmVkRmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcclxuICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgICAgICAgY29uc3QgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyBhcyBudW1iZXJbXVtdXHJcbiAgICAgICAgY29vcmRzLmZvckVhY2goKGNvb3JkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgZGlzcGxheUZlYXR1cmVzLnB1c2goe1xyXG4gICAgICAgICAgICAuLi5mZWF0dXJlLFxyXG4gICAgICAgICAgICBpZDogYCR7ZmVhdHVyZS5pZH0tbG9jLSR7aW5kZXh9YCxcclxuICAgICAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnUG9pbnQnIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGlzcGxheUZlYXR1cmVzLnB1c2goZmVhdHVyZSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGRhdGEgc291cmNlIFdJVEhPVVQgcmVidWlsZGluZyBsYXllcnMgLSBJTlNUQU5UIVxyXG4gICAgY29uc3QgZ2VvanNvbjogR2VvSlNPTi5GZWF0dXJlQ29sbGVjdGlvbiA9IHtcclxuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICAgICAgZmVhdHVyZXM6IGRpc3BsYXlGZWF0dXJlcyBhcyBhbnlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSBtYXAuY3VycmVudC5nZXRTb3VyY2UoJ21vdmllcycpIGFzIG1hcGxpYnJlZ2wuR2VvSlNPTlNvdXJjZVxyXG4gICAgaWYgKHNvdXJjZSAmJiBzb3VyY2Uuc2V0RGF0YSkge1xyXG4gICAgICBzb3VyY2Uuc2V0RGF0YShnZW9qc29uKVxyXG4gICAgfVxyXG4gIH0sIFtnZW9qc29uRmVhdHVyZXMsIG1vdmllcywgZmlsdGVycywgZm9jdXNlZE1vdmllSWRdKSAvLyBVcGRhdGUgZGF0YSB3aGVuIGZpbHRlcnMvZm9jdXMgY2hhbmdlXHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBzZWxlY3RlZCBtb3ZpZVxyXG4gICAqL1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcC5jdXJyZW50IHx8ICFzZWxlY3RlZE1vdmllKSByZXR1cm5cclxuXHJcbiAgICBjb25zdCBib3VuZHMgPSBuZXcgbWFwbGlicmVnbC5MbmdMYXRCb3VuZHMoKVxyXG4gICAgc2VsZWN0ZWRNb3ZpZS5sb2NhdGlvbnMuZm9yRWFjaCgobG9jYXRpb24pID0+IHtcclxuICAgICAgYm91bmRzLmV4dGVuZChbbG9jYXRpb24ubG5nLCBsb2NhdGlvbi5sYXRdKVxyXG4gICAgfSlcclxuXHJcbiAgICBtYXAuY3VycmVudC5maXRCb3VuZHMoYm91bmRzLCB7XHJcbiAgICAgIHBhZGRpbmc6IDEwMCxcclxuICAgICAgZHVyYXRpb246IDEwMDAsXHJcbiAgICB9KVxyXG4gIH0sIFtzZWxlY3RlZE1vdmllXSlcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWFwLWNvbnRhaW5lclwiPlxyXG4gICAgICB7LyogU3RhcnMgYmFja2dyb3VuZCAqL31cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzdGFycy1iYWNrZ3JvdW5kXCIgLz5cclxuXHJcbiAgICAgIHsvKiBNYXAgY29udGFpbmVyICovfVxyXG4gICAgICA8ZGl2IHJlZj17bWFwQ29udGFpbmVyfSBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIHpJbmRleDogMSB9fSAvPlxyXG5cclxuICAgICAgey8qIExvYWRpbmcgU2NyZWVuIE92ZXJsYXkgKi99XHJcbiAgICAgIHtsb2FkaW5nU3RhdGUuaXNMb2FkaW5nICYmIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgei01MCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1ncmFkaWVudC10by1iciBmcm9tLWdyYXktOTAwIHZpYS1wdXJwbGUtOTAwIHRvLWdyYXktOTAwXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHNwYWNlLXktNiBweC04XCI+XHJcbiAgICAgICAgICAgIHsvKiBNb3ZpZSBlbW9qaSBhbmltYXRpb24gKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC03eGwgYW5pbWF0ZS1ib3VuY2VcIj5cclxuICAgICAgICAgICAgICDwn46sXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgey8qIFRpdGxlICovfVxyXG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0zeGwgZm9udC1ib2xkIHRleHQtd2hpdGVcIj5cclxuICAgICAgICAgICAgICBDaW5lTWFwXHJcbiAgICAgICAgICAgIDwvaDI+XHJcblxyXG4gICAgICAgICAgICB7LyogTG9hZGluZyBzdGFnZSB0ZXh0ICovfVxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhsIHRleHQtZ3JheS0zMDBcIj5cclxuICAgICAgICAgICAgICB7bG9hZGluZ1N0YXRlLnN0YWdlfVxyXG4gICAgICAgICAgICA8L3A+XHJcblxyXG4gICAgICAgICAgICB7LyogUHJvZ3Jlc3MgYmFyICovfVxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctODAgYmctZ3JheS03MDAgcm91bmRlZC1mdWxsIGgtMyBvdmVyZmxvdy1oaWRkZW5cIj5cclxuICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmFkaWVudC10by1yIGZyb20tcHJpbWFyeS01MDAgdG8tcHVycGxlLTYwMCBoLWZ1bGwgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2Utb3V0XCJcclxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiBgJHtsb2FkaW5nU3RhdGUucHJvZ3Jlc3N9JWAgfX1cclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBQcm9ncmVzcyBwZXJjZW50YWdlICovfVxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDAgZm9udC1tb25vXCI+XHJcbiAgICAgICAgICAgICAge01hdGgucm91bmQobG9hZGluZ1N0YXRlLnByb2dyZXNzKX0lXHJcbiAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApfVxyXG5cclxuICAgICAgey8qIE1vdmllIGNvdW50IGJhZGdlICovfVxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0yMCBsZWZ0LTQgei0xMCBiZy1ibGFjay83MCBiYWNrZHJvcC1ibHVyLXNtIHRleHQtd2hpdGUgcHgtNCBweS0yIHJvdW5kZWQtbGcgc2hhZG93LXhsIGJvcmRlciBib3JkZXItd2hpdGUvMTBcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bFwiPvCfjqw8L3NwYW4+XHJcbiAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS0zMDBcIj5Ub3RhbCBNb3ZpZXM8L3A+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkXCI+XHJcbiAgICAgICAgICAgICAge21vdmllcy5sZW5ndGh9XHJcbiAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIClcclxufSlcclxuXHJcbk1hcC5kaXNwbGF5TmFtZSA9ICdNYXAnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXBcclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImZvcndhcmRSZWYiLCJtYXBsaWJyZWdsIiwiZmlsdGVyTW92aWVzIiwiTWFwIiwicmVmIiwic2VsZWN0ZWRNb3ZpZSIsIm9uTW92aWVTZWxlY3QiLCJzZWFyY2hRdWVyeSIsIl9zZWFyY2hRdWVyeSIsImZpbHRlcnMiLCJmb2N1c2VkTW92aWVJZCIsIm9uQ2xlYXJGb2N1cyIsIm1hcENvbnRhaW5lciIsIm1hcCIsIm1vdmllcyIsInNldE1vdmllcyIsImdlb2pzb25GZWF0dXJlcyIsInNldEdlb2pzb25GZWF0dXJlcyIsImluaXRpYWxpemVkUmVmIiwibG9hZGVkSW1hZ2VzUmVmIiwiU2V0IiwibG9hZGluZ1N0YXRlIiwic2V0TG9hZGluZ1N0YXRlIiwiaXNMb2FkaW5nIiwicHJvZ3Jlc3MiLCJzdGFnZSIsInNob3dBbGxMb2NhdGlvbnNGb3JNb3ZpZSIsIm1vdmllIiwiZmVhdHVyZSIsImZpbmQiLCJmIiwicHJvcGVydGllcyIsIm1vdmllX2lkIiwic2hvd0FsbExvY2F0aW9ucyIsImZseVRvTG9jYXRpb24iLCJsYXQiLCJsbmciLCJjdXJyZW50IiwiZmx5VG8iLCJjZW50ZXIiLCJ6b29tIiwiZHVyYXRpb24iLCJlc3NlbnRpYWwiLCJjb252ZXJ0RmVhdHVyZVRvTW92aWUiLCJsb2NhdGlvbnMiLCJnZW9tZXRyeSIsInR5cGUiLCJjb29yZGluYXRlcyIsImNpdHkiLCJsb2NhdGlvbl9uYW1lcyIsInNwbGl0IiwiY291bnRyeSIsInRyaW0iLCJkZXNjcmlwdGlvbiIsIm1hdGNoIiwiY29vcmRzIiwiY29vcmQiLCJpZHgiLCJsb2NhdGlvbk5hbWUiLCJzIiwidGl0bGUiLCJ5ZWFyIiwiaW1kYl9pZCIsInRtZGJfaWQiLCJTdHJpbmciLCJnZW5yZXMiLCJ0b3BfZ2VucmUiLCJwb3N0ZXIiLCJ1bmRlZmluZWQiLCJ0cmFpbGVyIiwiaW1kYl9yYXRpbmciLCJsb2FkRGF0YSIsImdlb2pzb25SZXNwb25zZSIsImZldGNoIiwiZ2VvanNvbkRhdGEiLCJqc29uIiwiZmVhdHVyZXMiLCJtb3ZpZXNGcm9tR2VvSlNPTiIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJlcnJvciIsImNvbnRhaW5lciIsInN0eWxlIiwiaXNVc2VySW50ZXJhY3RpbmciLCJyb3RhdGlvbkFuaW1hdGlvbiIsInN0YXJ0Um90YXRpb24iLCJyb3RhdGVDYW1lcmEiLCJfdGltZXN0YW1wIiwic2Vjb25kc1BlclJldm9sdXRpb24iLCJnZXRDZW50ZXIiLCJzZXRDZW50ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdG9wUm90YXRpb24iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uIiwic2V0UHJvamVjdGlvbiIsInNhdmVkU3RhdGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2V0Wm9vbSIsImUiLCJzZXRUaW1lb3V0Iiwic2F2ZVRpbWVvdXQiLCJzYXZlTWFwU3RhdGUiLCJnZXRab29tIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImNsZWFyVGltZW91dCIsImFkZENvbnRyb2wiLCJOYXZpZ2F0aW9uQ29udHJvbCIsIkZ1bGxzY3JlZW5Db250cm9sIiwicmVtb3ZlIiwiY3JlYXRlUG9zdGVySWNvbiIsInBvc3RlclBhdGgiLCJfbW92aWVJZCIsIl9pc011bHRpTG9jYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNpemUiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJiZWdpblBhdGgiLCJhcmMiLCJNYXRoIiwiUEkiLCJmaWxsU3R5bGUiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJmb250IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJkYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsInNhdmUiLCJjbGlwIiwiZHJhd0ltYWdlIiwicmVzdG9yZSIsIm9uZXJyb3IiLCJzcmMiLCJib3VuZHMiLCJMbmdMYXRCb3VuZHMiLCJmb3JFYWNoIiwiZXh0ZW5kIiwiZml0Qm91bmRzIiwicGFkZGluZyIsIm1heFpvb20iLCJnZXRMYXllciIsInJlbW92ZUxheWVyIiwiZ2V0U291cmNlIiwicmVtb3ZlU291cmNlIiwiYWRkU291cmNlIiwiYWRkTGF5ZXIiLCJpZCIsInNvdXJjZSIsInBhaW50IiwiaW5pdGlhbGl6ZU1hcmtlcnMiLCJCQVRDSF9TSVpFIiwibG9hZGVkQ291bnQiLCJhbGxGZWF0dXJlcyIsImkiLCJiYXRjaCIsInNsaWNlIiwiYWxsIiwibW92aWVJZCIsImlzTXVsdGlMb2NhdGlvbiIsImxvY2F0aW9uc19jb3VudCIsImljb25OYW1lIiwiaGFzSW1hZ2UiLCJwb3N0ZXJJY29uIiwiYWRkSW1hZ2UiLCJhZGQiLCJmYWxsYmFja0ljb24iLCJyb3VuZCIsImRpc3BsYXlGZWF0dXJlcyIsImluZGV4IiwicHVzaCIsImdlb2pzb24iLCJjbHVzdGVyIiwibGF5b3V0IiwiaGFuZGxlTWFya2VyQ2xpY2siLCJmZWF0dXJlQnlNb3ZpZUlkIiwibW92aWVGcm9tRmVhdHVyZSIsIm1vdmllRnJvbUNsaWNrIiwiaGFuZGxlTWFwQ2xpY2siLCJnZXRDYW52YXMiLCJjdXJzb3IiLCJpc1N0eWxlTG9hZGVkIiwiZmlsdGVyZWRGZWF0dXJlcyIsImZpbHRlciIsImZpbHRlcmVkTW92aWVzIiwiZmlsdGVyZWRJZHMiLCJtIiwiaGFzIiwic2V0RGF0YSIsImxvY2F0aW9uIiwiZGl2IiwiY2xhc3NOYW1lIiwicG9zaXRpb24iLCJ6SW5kZXgiLCJoMiIsInAiLCJzcGFuIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6785\n"));

/***/ }),

/***/ 2630:
/*!******************************!*\
  !*** ./src/utils/helpers.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   debounce: function() { return /* binding */ debounce; },\n/* harmony export */   filterMovies: function() { return /* binding */ filterMovies; },\n/* harmony export */   formatRating: function() { return /* binding */ formatRating; },\n/* harmony export */   formatYearRange: function() { return /* binding */ formatYearRange; },\n/* harmony export */   getUniqueCountries: function() { return /* binding */ getUniqueCountries; },\n/* harmony export */   getUniqueGenres: function() { return /* binding */ getUniqueGenres; },\n/* harmony export */   getUniqueStreamingPlatforms: function() { return /* binding */ getUniqueStreamingPlatforms; },\n/* harmony export */   getYouTubeEmbedUrl: function() { return /* binding */ getYouTubeEmbedUrl; },\n/* harmony export */   getYouTubeVideoId: function() { return /* binding */ getYouTubeVideoId; }\n/* harmony export */ });\n/**\r\n * General utility functions\r\n */ /**\r\n * Format year range for display\r\n */ const formatYearRange = (start, end)=>{\n    if (start === end) return \"\".concat(start);\n    return \"\".concat(start, \"-\").concat(end);\n};\n/**\r\n * Get unique list of genres from movies\r\n */ const getUniqueGenres = (movies)=>{\n    const genresSet = new Set();\n    movies.forEach((movie)=>{\n        movie.genres.forEach((genre)=>genresSet.add(genre));\n    });\n    return Array.from(genresSet).sort();\n};\n/**\r\n * Get unique list of streaming platforms\r\n */ const getUniqueStreamingPlatforms = (movies)=>{\n    const platformsSet = new Set();\n    movies.forEach((movie)=>{\n        var _movie_streaming;\n        (_movie_streaming = movie.streaming) === null || _movie_streaming === void 0 ? void 0 : _movie_streaming.forEach((platform)=>platformsSet.add(platform));\n    });\n    return Array.from(platformsSet).sort();\n};\n/**\r\n * Get unique list of countries\r\n */ const getUniqueCountries = (movies)=>{\n    const countriesSet = new Set();\n    movies.forEach((movie)=>{\n        movie.locations.forEach((loc)=>countriesSet.add(loc.country));\n    });\n    return Array.from(countriesSet).sort();\n};\n/**\r\n * Filter movies by criteria\r\n */ const filterMovies = (movies, filters)=>{\n    return movies.filter((movie)=>{\n        // Genre filter\n        if (filters.genres.length > 0) {\n            const hasMatchingGenre = movie.genres.some((genre)=>filters.genres.includes(genre));\n            if (!hasMatchingGenre) return false;\n        }\n        // Decade filter\n        if (movie.year < filters.decades[0] || movie.year > filters.decades[1]) {\n            return false;\n        }\n        // Streaming filter\n        if (filters.streaming.length > 0 && movie.streaming) {\n            const hasMatchingPlatform = movie.streaming.some((platform)=>filters.streaming.includes(platform));\n            if (!hasMatchingPlatform) return false;\n        }\n        return true;\n    });\n};\n/**\r\n * Debounce function for search input\r\n */ const debounce = (func, wait)=>{\n    let timeout = null;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(()=>func(...args), wait);\n    };\n};\n/**\r\n * Format IMDb rating for display\r\n */ const formatRating = (rating)=>{\n    if (!rating) return \"N/A\";\n    return rating.toFixed(1);\n};\n/**\r\n * Extract YouTube video ID from URL\r\n */ const getYouTubeVideoId = (url)=>{\n    if (!url) return null;\n    const match = url.match(/[?&]v=([^&]+)/);\n    return match ? match[1] : null;\n};\n/**\r\n * Generate YouTube embed URL\r\n */ const getYouTubeEmbedUrl = (url)=>{\n    const videoId = getYouTubeVideoId(url);\n    return videoId ? \"https://www.youtube.com/embed/\".concat(videoId) : null;\n};\n/**\r\n * Clamp a number between min and max\r\n */ const clamp = (value, min, max)=>{\n    return Math.min(Math.max(value, min), max);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2pCLE1BQU1DLFFBQVFELElBQUlDLEtBQUssQ0FBQztJQUN4QixPQUFPQSxRQUFRQSxLQUFLLENBQUMsRUFBRSxHQUFHO0FBQzVCLEVBQUM7QUFFRDs7Q0FFQyxHQUNNLE1BQU1DLHFCQUFxQixDQUFDRjtJQUNqQyxNQUFNRyxVQUFVSixrQkFBa0JDO0lBQ2xDLE9BQU9HLFVBQVUsaUNBQXlDLE9BQVJBLFdBQVk7QUFDaEUsRUFBQztBQUVEOztDQUVDLEdBQ00sTUFBTUMsUUFBUSxDQUFDQyxPQUFlQyxLQUFhQztJQUNoRCxPQUFPQyxLQUFLRixHQUFHLENBQUNFLEtBQUtELEdBQUcsQ0FBQ0YsT0FBT0MsTUFBTUM7QUFDeEMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvaGVscGVycy50cz82OWFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBHZW5lcmFsIHV0aWxpdHkgZnVuY3Rpb25zXHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUgeyBNb3ZpZSB9IGZyb20gJy4uL3R5cGVzJ1xyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCB5ZWFyIHJhbmdlIGZvciBkaXNwbGF5XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZm9ybWF0WWVhclJhbmdlID0gKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBpZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuIGAke3N0YXJ0fWBcclxuICByZXR1cm4gYCR7c3RhcnR9LSR7ZW5kfWBcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgbGlzdCBvZiBnZW5yZXMgZnJvbSBtb3ZpZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVbmlxdWVHZW5yZXMgPSAobW92aWVzOiByZWFkb25seSBNb3ZpZVtdKTogc3RyaW5nW10gPT4ge1xyXG4gIGNvbnN0IGdlbnJlc1NldCA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgbW92aWVzLmZvckVhY2gobW92aWUgPT4ge1xyXG4gICAgbW92aWUuZ2VucmVzLmZvckVhY2goZ2VucmUgPT4gZ2VucmVzU2V0LmFkZChnZW5yZSkpXHJcbiAgfSlcclxuICByZXR1cm4gQXJyYXkuZnJvbShnZW5yZXNTZXQpLnNvcnQoKVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHVuaXF1ZSBsaXN0IG9mIHN0cmVhbWluZyBwbGF0Zm9ybXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVbmlxdWVTdHJlYW1pbmdQbGF0Zm9ybXMgPSAobW92aWVzOiByZWFkb25seSBNb3ZpZVtdKTogc3RyaW5nW10gPT4ge1xyXG4gIGNvbnN0IHBsYXRmb3Jtc1NldCA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgbW92aWVzLmZvckVhY2gobW92aWUgPT4ge1xyXG4gICAgbW92aWUuc3RyZWFtaW5nPy5mb3JFYWNoKHBsYXRmb3JtID0+IHBsYXRmb3Jtc1NldC5hZGQocGxhdGZvcm0pKVxyXG4gIH0pXHJcbiAgcmV0dXJuIEFycmF5LmZyb20ocGxhdGZvcm1zU2V0KS5zb3J0KClcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgbGlzdCBvZiBjb3VudHJpZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVbmlxdWVDb3VudHJpZXMgPSAobW92aWVzOiByZWFkb25seSBNb3ZpZVtdKTogc3RyaW5nW10gPT4ge1xyXG4gIGNvbnN0IGNvdW50cmllc1NldCA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgbW92aWVzLmZvckVhY2gobW92aWUgPT4ge1xyXG4gICAgbW92aWUubG9jYXRpb25zLmZvckVhY2gobG9jID0+IGNvdW50cmllc1NldC5hZGQobG9jLmNvdW50cnkpKVxyXG4gIH0pXHJcbiAgcmV0dXJuIEFycmF5LmZyb20oY291bnRyaWVzU2V0KS5zb3J0KClcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbHRlciBtb3ZpZXMgYnkgY3JpdGVyaWFcclxuICovXHJcbmV4cG9ydCBjb25zdCBmaWx0ZXJNb3ZpZXMgPSAoXHJcbiAgbW92aWVzOiByZWFkb25seSBNb3ZpZVtdLFxyXG4gIGZpbHRlcnM6IHtcclxuICAgIGdlbnJlczogc3RyaW5nW11cclxuICAgIGRlY2FkZXM6IFtudW1iZXIsIG51bWJlcl1cclxuICAgIHN0cmVhbWluZzogc3RyaW5nW11cclxuICB9XHJcbik6IE1vdmllW10gPT4ge1xyXG4gIHJldHVybiBtb3ZpZXMuZmlsdGVyKG1vdmllID0+IHtcclxuICAgIC8vIEdlbnJlIGZpbHRlclxyXG4gICAgaWYgKGZpbHRlcnMuZ2VucmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgaGFzTWF0Y2hpbmdHZW5yZSA9IG1vdmllLmdlbnJlcy5zb21lKGdlbnJlID0+XHJcbiAgICAgICAgZmlsdGVycy5nZW5yZXMuaW5jbHVkZXMoZ2VucmUpXHJcbiAgICAgIClcclxuICAgICAgaWYgKCFoYXNNYXRjaGluZ0dlbnJlKSByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWNhZGUgZmlsdGVyXHJcbiAgICBpZiAobW92aWUueWVhciA8IGZpbHRlcnMuZGVjYWRlc1swXSB8fCBtb3ZpZS55ZWFyID4gZmlsdGVycy5kZWNhZGVzWzFdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmVhbWluZyBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJzLnN0cmVhbWluZy5sZW5ndGggPiAwICYmIG1vdmllLnN0cmVhbWluZykge1xyXG4gICAgICBjb25zdCBoYXNNYXRjaGluZ1BsYXRmb3JtID0gbW92aWUuc3RyZWFtaW5nLnNvbWUocGxhdGZvcm0gPT5cclxuICAgICAgICBmaWx0ZXJzLnN0cmVhbWluZy5pbmNsdWRlcyhwbGF0Zm9ybSlcclxuICAgICAgKVxyXG4gICAgICBpZiAoIWhhc01hdGNoaW5nUGxhdGZvcm0pIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIERlYm91bmNlIGZ1bmN0aW9uIGZvciBzZWFyY2ggaW5wdXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWJvdW5jZSA9IDxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxyXG4gIGZ1bmM6IFQsXHJcbiAgd2FpdDogbnVtYmVyXHJcbik6ICgoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4gdm9pZCkgPT4ge1xyXG4gIGxldCB0aW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGwgPSBudWxsXHJcblxyXG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KVxyXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZnVuYyguLi5hcmdzKSwgd2FpdClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgSU1EYiByYXRpbmcgZm9yIGRpc3BsYXlcclxuICovXHJcbmV4cG9ydCBjb25zdCBmb3JtYXRSYXRpbmcgPSAocmF0aW5nPzogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBpZiAoIXJhdGluZykgcmV0dXJuICdOL0EnXHJcbiAgcmV0dXJuIHJhdGluZy50b0ZpeGVkKDEpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IFlvdVR1YmUgdmlkZW8gSUQgZnJvbSBVUkxcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRZb3VUdWJlVmlkZW9JZCA9ICh1cmw/OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICBpZiAoIXVybCkgcmV0dXJuIG51bGxcclxuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvWz8mXXY9KFteJl0rKS8pXHJcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBZb3VUdWJlIGVtYmVkIFVSTFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFlvdVR1YmVFbWJlZFVybCA9ICh1cmw/OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICBjb25zdCB2aWRlb0lkID0gZ2V0WW91VHViZVZpZGVvSWQodXJsKVxyXG4gIHJldHVybiB2aWRlb0lkID8gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLyR7dmlkZW9JZH1gIDogbnVsbFxyXG59XHJcblxyXG4vKipcclxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNsYW1wID0gKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpXHJcbn1cclxuIl0sIm5hbWVzIjpbImZvcm1hdFllYXJSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZ2V0VW5pcXVlR2VucmVzIiwibW92aWVzIiwiZ2VucmVzU2V0IiwiU2V0IiwiZm9yRWFjaCIsIm1vdmllIiwiZ2VucmVzIiwiZ2VucmUiLCJhZGQiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiZ2V0VW5pcXVlU3RyZWFtaW5nUGxhdGZvcm1zIiwicGxhdGZvcm1zU2V0Iiwic3RyZWFtaW5nIiwicGxhdGZvcm0iLCJnZXRVbmlxdWVDb3VudHJpZXMiLCJjb3VudHJpZXNTZXQiLCJsb2NhdGlvbnMiLCJsb2MiLCJjb3VudHJ5IiwiZmlsdGVyTW92aWVzIiwiZmlsdGVycyIsImZpbHRlciIsImxlbmd0aCIsImhhc01hdGNoaW5nR2VucmUiLCJzb21lIiwiaW5jbHVkZXMiLCJ5ZWFyIiwiZGVjYWRlcyIsImhhc01hdGNoaW5nUGxhdGZvcm0iLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwidGltZW91dCIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZm9ybWF0UmF0aW5nIiwicmF0aW5nIiwidG9GaXhlZCIsImdldFlvdVR1YmVWaWRlb0lkIiwidXJsIiwibWF0Y2giLCJnZXRZb3VUdWJlRW1iZWRVcmwiLCJ2aWRlb0lkIiwiY2xhbXAiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsIk1hdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2630\n"));

/***/ })

}]);