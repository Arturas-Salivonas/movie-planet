"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_MapWrapper_tsx"],{

/***/ 6785:
/*!********************************!*\
  !*** ./src/components/Map.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ 3068);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ 2265);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maplibre-gl */ 7762);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(maplibre_gl__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/helpers */ 2630);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n/**\r\n * Map Component - MapLibre GL JS map with globe projection and multi-location support\r\n * Updated for Next.js - no hash routing, uses localStorage for map state\r\n */ \n\n\nconst Map = /*#__PURE__*/ _s((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = _s((param, ref)=>{\n    let { selectedMovie, onMovieSelect, searchQuery: _searchQuery, filters, focusedMovieId, onClearFocus } = param;\n    _s();\n    const mapContainer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [movies, setMovies] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [geojsonFeatures, setGeojsonFeatures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const initializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Track which poster images have been loaded to prevent redundant loading\n    const loadedImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Loading state for progressive rendering\n    const [loadingState, setLoadingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        isLoading: true,\n        progress: 0,\n        stage: \"Initializing...\"\n    });\n    // Expose methods to parent component\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, ()=>({\n            showAllLocationsForMovie: (movie)=>{\n                console.log(\"\\uD83D\\uDDFA️ Map.showAllLocationsForMovie called\", {\n                    movieId: movie.movie_id,\n                    hasMap: !!map.current,\n                    featuresLength: geojsonFeatures.length\n                });\n                if (!map.current) {\n                    console.error(\"❌ Map not initialized\");\n                    return;\n                }\n                const feature = geojsonFeatures.find((f)=>f.properties.movie_id === movie.movie_id);\n                if (!feature) {\n                    console.error(\"❌ Feature not found for movie\", movie.movie_id);\n                    return;\n                }\n                console.log(\"✅ Feature found, drawing lines\", feature);\n                const coordinates = feature.geometry.type === \"MultiPoint\" ? feature.geometry.coordinates : [\n                    feature.geometry.coordinates\n                ];\n                console.log(\"\\uD83D\\uDCCD Coordinates:\", coordinates);\n                // Calculate bounds\n                const bounds = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().LngLatBounds)();\n                coordinates.forEach((coord)=>bounds.extend(coord));\n                // Fit map to bounds\n                map.current.fitBounds(bounds, {\n                    padding: 100,\n                    maxZoom: 10,\n                    duration: 1000\n                });\n                // Remove existing connecting line\n                if (map.current.getLayer(\"connecting-line\")) {\n                    map.current.removeLayer(\"connecting-line\");\n                }\n                if (map.current.getSource(\"connecting-line\")) {\n                    map.current.removeSource(\"connecting-line\");\n                }\n                // Draw connecting polyline for multi-location movies\n                if (coordinates.length > 1) {\n                    console.log(\"✅ Drawing line with\", coordinates.length, \"points\");\n                    map.current.addSource(\"connecting-line\", {\n                        type: \"geojson\",\n                        data: {\n                            type: \"Feature\",\n                            geometry: {\n                                type: \"LineString\",\n                                coordinates\n                            },\n                            properties: {}\n                        }\n                    });\n                    map.current.addLayer({\n                        id: \"connecting-line\",\n                        type: \"line\",\n                        source: \"connecting-line\",\n                        paint: {\n                            \"line-color\": \"#F59E0B\",\n                            \"line-width\": 4,\n                            \"line-opacity\": 0.9,\n                            \"line-blur\": 1\n                        }\n                    });\n                } else {\n                    console.log(\"ℹ️ Only 1 location, no line needed\");\n                }\n            },\n            flyToLocation: (lat, lng)=>{\n                if (map.current) {\n                    const targetZoom = 12;\n                    map.current.setProjection({\n                        type: \"mercator\"\n                    });\n                    // Use flyTo for smooth animation in mercator with faster duration\n                    map.current.flyTo({\n                        center: [\n                            lng,\n                            lat\n                        ],\n                        zoom: targetZoom,\n                        duration: 1200,\n                        essential: true\n                    });\n                    // Wait for mercator animation to complete, then switch to globe\n                    setTimeout(()=>{\n                        if (!map.current) return;\n                        map.current.setProjection({\n                            type: \"globe\"\n                        });\n                        // Re-apply center and zoom after globe switch with easeTo for smooth transition\n                        map.current.easeTo({\n                            center: [\n                                lng,\n                                lat\n                            ],\n                            zoom: targetZoom,\n                            duration: 600,\n                            essential: true\n                        });\n                    }, 1300);\n                }\n            },\n            resetView: ()=>{\n                if (map.current) {\n                    // Remove debug marker if exists\n                    if (map.current.getSource(\"debug-marker\")) {\n                        map.current.removeLayer(\"debug-marker\");\n                        map.current.removeSource(\"debug-marker\");\n                    }\n                    // Remove connecting line if exists\n                    if (map.current.getLayer(\"connecting-line\")) {\n                        map.current.removeLayer(\"connecting-line\");\n                    }\n                    if (map.current.getSource(\"connecting-line\")) {\n                        map.current.removeSource(\"connecting-line\");\n                    }\n                    // Reset to default view (Europe centered)\n                    map.current.flyTo({\n                        center: [\n                            0.35,\n                            43\n                        ],\n                        zoom: 2.88,\n                        duration: 1500,\n                        essential: true\n                    });\n                }\n            }\n        }), [\n        geojsonFeatures\n    ]);\n    /**\r\n   * Convert GeoJSON feature to Movie object\r\n   */ const convertFeatureToMovie = (feature)=>{\n        // Extract locations from geometry\n        let locations = [];\n        if (feature.geometry.type === \"Point\") {\n            var _feature_properties_location_names_, _feature_properties_location_names__split_, _feature_properties_location_names_1, _feature_properties_location_names__match, _feature_properties_location_names_2;\n            const [lng, lat] = feature.geometry.coordinates;\n            locations = [\n                {\n                    lat,\n                    lng,\n                    city: ((_feature_properties_location_names_ = feature.properties.location_names[0]) === null || _feature_properties_location_names_ === void 0 ? void 0 : _feature_properties_location_names_.split(\",\")[0]) || \"Unknown\",\n                    country: ((_feature_properties_location_names_1 = feature.properties.location_names[0]) === null || _feature_properties_location_names_1 === void 0 ? void 0 : (_feature_properties_location_names__split_ = _feature_properties_location_names_1.split(\",\")[1]) === null || _feature_properties_location_names__split_ === void 0 ? void 0 : _feature_properties_location_names__split_.trim()) || \"Unknown\",\n                    description: ((_feature_properties_location_names_2 = feature.properties.location_names[0]) === null || _feature_properties_location_names_2 === void 0 ? void 0 : (_feature_properties_location_names__match = _feature_properties_location_names_2.match(/\\((.*?)\\)/)) === null || _feature_properties_location_names__match === void 0 ? void 0 : _feature_properties_location_names__match[1]) || \"\"\n                }\n            ];\n        } else if (feature.geometry.type === \"MultiPoint\") {\n            const coords = feature.geometry.coordinates;\n            locations = coords.map((coord, idx)=>{\n                var _locationName_match;\n                const [lng, lat] = coord;\n                const locationName = feature.properties.location_names[idx] || \"Unknown\";\n                const [city, country] = locationName.split(\",\").map((s)=>s.trim());\n                const description = ((_locationName_match = locationName.match(/\\((.*?)\\)/)) === null || _locationName_match === void 0 ? void 0 : _locationName_match[1]) || \"\";\n                return {\n                    lat,\n                    lng,\n                    city: city || \"Unknown\",\n                    country: country || \"Unknown\",\n                    description\n                };\n            });\n        }\n        return {\n            movie_id: feature.properties.movie_id,\n            title: feature.properties.title,\n            year: feature.properties.year,\n            imdb_id: feature.properties.movie_id,\n            tmdb_id: String(feature.properties.tmdb_id),\n            genres: feature.properties.genres || (feature.properties.top_genre ? [\n                feature.properties.top_genre\n            ] : []),\n            poster: feature.properties.poster || undefined,\n            trailer: feature.properties.trailer || undefined,\n            imdb_rating: feature.properties.imdb_rating || undefined,\n            locations\n        };\n    };\n    /**\r\n   * Load movies data and GeoJSON with progressive loading\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            try {\n                // Load GeoJSON features\n                const geojsonResponse = await fetch(\"/geo/movies.geojson\");\n                const geojsonData = await geojsonResponse.json();\n                // Store all features for filtering\n                setGeojsonFeatures(geojsonData.features);\n                // Convert all GeoJSON features to Movie objects\n                const moviesFromGeoJSON = geojsonData.features.map(convertFeatureToMovie);\n                setMovies(moviesFromGeoJSON);\n                console.log(\"\\uD83D\\uDCCA Loaded \".concat(geojsonData.features.length, \" movies for progressive rendering\"));\n            } catch (error) {\n                console.error(\"Failed to load data:\", error);\n            }\n        };\n        loadData();\n    }, []);\n    /**\r\n   * Initialize map\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapContainer.current || map.current) return;\n        map.current = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Map)({\n            container: mapContainer.current,\n            // Use MapTiler basic style - free tier, works with globe\n            style: \"https://api.maptiler.com/maps/basic-v2/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL\",\n            zoom: 2.88,\n            center: [\n                0.35,\n                43\n            ]\n        });\n        // Globe rotation animation\n        let isUserInteracting = false;\n        let rotationAnimation = null;\n        const startRotation = ()=>{\n            if (!map.current || isUserInteracting) return;\n            const rotateCamera = (_timestamp)=>{\n                if (!map.current || isUserInteracting) return;\n                // Rotate 360 degrees over 2 minutes (120 seconds)\n                const secondsPerRevolution = 720;\n                const center = map.current.getCenter();\n                center.lng = (center.lng + 360 / secondsPerRevolution * (1 / 60)) % 360;\n                map.current.setCenter(center);\n                rotationAnimation = requestAnimationFrame(rotateCamera);\n            };\n            rotationAnimation = requestAnimationFrame(rotateCamera);\n        };\n        const stopRotation = ()=>{\n            isUserInteracting = true;\n            if (rotationAnimation !== null) {\n                cancelAnimationFrame(rotationAnimation);\n                rotationAnimation = null;\n            }\n        };\n        map.current.on(\"style.load\", ()=>{\n            if (map.current) {\n                // Set projection to globe\n                map.current.setProjection({\n                    type: \"globe\"\n                });\n                // Restore map position from localStorage (clean URLs)\n                if (true) {\n                    const savedState = localStorage.getItem(\"cinemap_view\");\n                    if (savedState) {\n                        try {\n                            const { lat, lng, zoom } = JSON.parse(savedState);\n                            map.current.setCenter([\n                                lng,\n                                lat\n                            ]);\n                            map.current.setZoom(zoom);\n                        } catch (e) {\n                        // Ignore invalid stored state\n                        }\n                    }\n                }\n                // Start rotation after map loads\n                setTimeout(startRotation, 1000);\n            }\n        });\n        // Save map position to localStorage on movement (debounced)\n        let saveTimeout = null;\n        const saveMapState = ()=>{\n            if (!map.current || \"object\" === \"undefined\") return;\n            const center = map.current.getCenter();\n            const zoom = map.current.getZoom();\n            localStorage.setItem(\"cinemap_view\", JSON.stringify({\n                lat: center.lat,\n                lng: center.lng,\n                zoom: zoom\n            }));\n        };\n        map.current.on(\"moveend\", ()=>{\n            if (saveTimeout) clearTimeout(saveTimeout);\n            saveTimeout = setTimeout(saveMapState, 500);\n        });\n        // Stop rotation on any user interaction\n        map.current.on(\"mousedown\", stopRotation);\n        map.current.on(\"touchstart\", stopRotation);\n        map.current.on(\"wheel\", stopRotation);\n        map.current.on(\"dragstart\", stopRotation);\n        // Add navigation controls\n        map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().NavigationControl)(), \"bottom-right\");\n        map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().FullscreenControl)(), \"bottom-right\");\n        // Don't add zoom listener here - it causes issues with tile loading\n        // We'll handle it differently\n        return ()=>{\n            if (map.current) {\n                map.current.remove();\n                map.current = null;\n            }\n        };\n    }, []);\n    /**\r\n   * Load and create poster image icon with movie badge\r\n   */ const createPosterIcon = async (posterPath, _movieId, _isMultiLocation)=>{\n        return new Promise((resolve)=>{\n            const size = 60 // Consistent size for all markers\n            ;\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = size;\n            canvas.height = size;\n            const ctx = canvas.getContext(\"2d\");\n            // If no poster, create fallback icon\n            if (!posterPath) {\n                // Create circular background\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.fillStyle = \"#3B82F6\";\n                ctx.fill();\n                // White border\n                ctx.strokeStyle = \"#FFFFFF\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                // Film icon\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.font = \"bold 24px Arial\";\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillText(\"\\uD83C\\uDFAC\", size / 2, size / 2);\n                resolve({\n                    width: size,\n                    height: size,\n                    data: ctx.getImageData(0, 0, size, size).data\n                });\n                return;\n            }\n            // Load poster image\n            const img = new Image();\n            img.crossOrigin = \"anonymous\";\n            img.onload = ()=>{\n                // Create circular clipping mask\n                ctx.save();\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.clip();\n                // Draw poster (centered and scaled)\n                ctx.drawImage(img, 0, 0, size, size);\n                ctx.restore();\n                // White border around circle\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.strokeStyle = \"#10be50ff\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                resolve({\n                    width: size,\n                    height: size,\n                    data: ctx.getImageData(0, 0, size, size).data\n                });\n            };\n            img.onerror = ()=>{\n                // Fallback on error - circular icon\n                ctx.beginPath();\n                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);\n                ctx.fillStyle = \"#3B82F6\";\n                ctx.fill();\n                ctx.strokeStyle = \"#FFFFFF\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                // Film icon fallback\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.font = \"bold 20px Arial\";\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillText(\"\\uD83C\\uDFAC\", size / 2, size / 2);\n                resolve({\n                    width: size,\n                    height: size,\n                    data: ctx.getImageData(0, 0, size, size).data\n                });\n            };\n            // Use the full poster URL from the data\n            img.src = posterPath;\n        });\n    };\n    /**\r\n   * Add movie markers from GeoJSON - INITIAL LOAD ONLY\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current || geojsonFeatures.length === 0) return;\n        // Only run this effect once when data is first loaded\n        if (initializedRef.current || map.current.getSource(\"movies\")) return;\n        async function initializeMarkers() {\n            if (!map.current) return;\n            // Load ALL posters BEFORE adding map layer (prevents warnings)\n            const BATCH_SIZE = 20;\n            let loadedCount = 0;\n            const allFeatures = geojsonFeatures;\n            // Only show loading on initial setup, not on StrictMode re-mounts\n            if (!initializedRef.current) {\n                setLoadingState({\n                    isLoading: true,\n                    progress: 90,\n                    stage: \"Loading posters... 0/\".concat(allFeatures.length)\n                });\n            }\n            // Load posters in batches and await completion\n            for(let i = 0; i < allFeatures.length; i += BATCH_SIZE){\n                const batch = allFeatures.slice(i, i + BATCH_SIZE);\n                await Promise.all(batch.map(async (feature)=>{\n                    const movieId = feature.properties.movie_id;\n                    const posterPath = feature.properties.poster;\n                    const isMultiLocation = feature.properties.locations_count > 1;\n                    const iconName = \"poster-\".concat(movieId);\n                    if (!map.current.hasImage(iconName)) {\n                        try {\n                            const posterIcon = await createPosterIcon(posterPath, movieId, isMultiLocation);\n                            map.current.addImage(iconName, posterIcon);\n                            loadedImagesRef.current.add(iconName) // Mark as loaded\n                            ;\n                            loadedCount++;\n                        } catch (error) {\n                            console.error(\"Failed to add poster icon for \".concat(movieId, \":\"), error);\n                            // Add fallback icon on error\n                            const fallbackIcon = await createPosterIcon(null, movieId, isMultiLocation);\n                            map.current.addImage(iconName, fallbackIcon);\n                            loadedImagesRef.current.add(iconName) // Mark as loaded\n                            ;\n                            loadedCount++;\n                        }\n                    } else {\n                        loadedCount++;\n                    }\n                }));\n                // Update progress after each batch\n                const progress = Math.round(loadedCount / allFeatures.length * 100);\n                setLoadingState({\n                    isLoading: true,\n                    progress: 90 + progress * 0.09,\n                    stage: \"Loading posters... \".concat(loadedCount, \"/\").concat(allFeatures.length)\n                });\n            }\n            // Show rendering stage only on initial setup\n            if (!initializedRef.current) {\n                setLoadingState({\n                    isLoading: true,\n                    progress: 99,\n                    stage: \"Rendering markers...\"\n                });\n            }\n            // Convert MultiPoint features into individual Point features for each location\n            const displayFeatures = [];\n            allFeatures.forEach((feature)=>{\n                if (feature.geometry.type === \"MultiPoint\") {\n                    // Create a separate feature for each location\n                    const coords = feature.geometry.coordinates;\n                    coords.forEach((coord, index)=>{\n                        displayFeatures.push({\n                            ...feature,\n                            id: \"\".concat(feature.id, \"-loc-\").concat(index),\n                            geometry: {\n                                type: \"Point\",\n                                coordinates: coord\n                            }\n                        });\n                    });\n                } else {\n                    // Single location - keep as is\n                    displayFeatures.push(feature);\n                }\n            });\n            // Create GeoJSON for display\n            const geojson = {\n                type: \"FeatureCollection\",\n                features: displayFeatures\n            };\n            // Add source - DISABLE clustering so markers stay visible\n            map.current.addSource(\"movies\", {\n                type: \"geojson\",\n                data: geojson,\n                // Clustering disabled - we want to see all markers\n                cluster: false\n            });\n            // Add all movie markers layer (now each marker represents one actual location)\n            map.current.addLayer({\n                id: \"movie-markers\",\n                type: \"symbol\",\n                source: \"movies\",\n                layout: {\n                    \"icon-image\": [\n                        \"concat\",\n                        \"poster-\",\n                        [\n                            \"get\",\n                            \"movie_id\"\n                        ]\n                    ],\n                    \"icon-size\": 0.7,\n                    \"icon-allow-overlap\": true,\n                    \"text-field\": [\n                        \"get\",\n                        \"title\"\n                    ],\n                    \"text-font\": [\n                        \"Open Sans Bold\",\n                        \"Arial Unicode MS Bold\"\n                    ],\n                    \"text-size\": 14,\n                    \"text-offset\": [\n                        0,\n                        2.8\n                    ],\n                    \"text-anchor\": \"top\",\n                    \"text-max-width\": 12,\n                    \"text-allow-overlap\": false\n                },\n                paint: {\n                    \"text-color\": \"#10be50ff\",\n                    \"text-halo-color\": \"#1F2937\",\n                    \"text-halo-width\": 2.5,\n                    \"text-halo-blur\": 1\n                }\n            });\n            // All done - hide loading screen only on initial setup\n            if (!initializedRef.current) {\n                setTimeout(()=>{\n                    setLoadingState({\n                        isLoading: false,\n                        progress: 100,\n                        stage: \"Complete\"\n                    });\n                    initializedRef.current = true;\n                }, 300) // Small delay for smooth transition\n                ;\n            }\n            // Add unified click handler for all movie markers\n            const handleMarkerClick = (e)=>{\n                if (!e.features || e.features.length === 0) return;\n                const feature = e.features[0];\n                // Try to find in geojsonFeatures by movie_id\n                const featureByMovieId = geojsonFeatures.find((f)=>f.properties.movie_id === feature.properties.movie_id);\n                if (featureByMovieId) {\n                    const movieFromFeature = convertFeatureToMovie(featureByMovieId);\n                    onMovieSelect(movieFromFeature);\n                // Don't automatically show all locations - let user click \"Show All on Map\" button\n                } else {\n                    // Last resort: create a minimal movie object\n                    const movieFromClick = {\n                        movie_id: feature.properties.movie_id,\n                        title: feature.properties.title,\n                        year: feature.properties.year,\n                        imdb_id: feature.properties.movie_id,\n                        tmdb_id: String(feature.properties.tmdb_id),\n                        genres: feature.properties.genres || (feature.properties.top_genre ? [\n                            feature.properties.top_genre\n                        ] : []),\n                        poster: feature.properties.poster || undefined,\n                        trailer: feature.properties.trailer || undefined,\n                        imdb_rating: feature.properties.imdb_rating || undefined,\n                        locations: [\n                            {\n                                lat: 0,\n                                lng: 0,\n                                city: \"Unknown\",\n                                country: \"Unknown\"\n                            }\n                        ]\n                    };\n                    onMovieSelect(movieFromClick);\n                }\n            };\n            map.current.on(\"click\", \"movie-markers\", handleMarkerClick);\n            // Clear focus when clicking on empty map (not on markers)\n            const handleMapClick = (e)=>{\n                // Only clear focus if clicking on empty space (not on markers)\n                if (!e.features || e.features.length === 0) {\n                    if (focusedMovieId && onClearFocus) {\n                        onClearFocus();\n                    }\n                }\n            };\n            map.current.on(\"click\", handleMapClick);\n            // Change cursor on hover\n            map.current.on(\"mouseenter\", \"movie-markers\", ()=>{\n                map.current.getCanvas().style.cursor = \"pointer\";\n            });\n            map.current.on(\"mouseleave\", \"movie-markers\", ()=>{\n                map.current.getCanvas().style.cursor = \"\";\n            });\n        }\n        // Wait for style to be loaded\n        if (!map.current.isStyleLoaded()) {\n            map.current.on(\"load\", ()=>{\n                initializeMarkers();\n            });\n        } else {\n            initializeMarkers();\n        }\n    }, [\n        geojsonFeatures\n    ]) // Only depend on geojsonFeatures - run once when data loads\n    ;\n    /**\r\n   * Update visible markers based on filters and focus - NO REBUILDING\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current || !map.current.getSource(\"movies\")) return;\n        let filteredFeatures;\n        // If a movie is focused, ONLY show that movie's markers (ignore all other filters)\n        if (focusedMovieId) {\n            filteredFeatures = geojsonFeatures.filter((f)=>f.properties.movie_id === focusedMovieId);\n        } else {\n            // Normal mode: apply search and filter logic\n            const filteredMovies = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.filterMovies)(movies, filters);\n            const filteredIds = new Set(filteredMovies.map((m)=>m.movie_id));\n            filteredFeatures = movies.length > 0 ? geojsonFeatures.filter((f)=>filteredIds.has(f.properties.movie_id)) : geojsonFeatures;\n        }\n        // Convert MultiPoint features into individual Point features\n        const displayFeatures = [];\n        filteredFeatures.forEach((feature)=>{\n            if (feature.geometry.type === \"MultiPoint\") {\n                const coords = feature.geometry.coordinates;\n                coords.forEach((coord, index)=>{\n                    displayFeatures.push({\n                        ...feature,\n                        id: \"\".concat(feature.id, \"-loc-\").concat(index),\n                        geometry: {\n                            type: \"Point\",\n                            coordinates: coord\n                        }\n                    });\n                });\n            } else {\n                displayFeatures.push(feature);\n            }\n        });\n        // Update the data source WITHOUT rebuilding layers - INSTANT!\n        const geojson = {\n            type: \"FeatureCollection\",\n            features: displayFeatures\n        };\n        const source = map.current.getSource(\"movies\");\n        if (source && source.setData) {\n            source.setData(geojson);\n        }\n    }, [\n        geojsonFeatures,\n        movies,\n        filters,\n        focusedMovieId\n    ]) // Update data when filters/focus change\n    ;\n    /**\r\n   * Clear connecting lines when focus is removed\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current) return;\n        // When focusedMovieId is cleared, remove the connecting lines\n        if (!focusedMovieId) {\n            if (map.current.getLayer(\"connecting-line\")) {\n                map.current.removeLayer(\"connecting-line\");\n            }\n            if (map.current.getSource(\"connecting-line\")) {\n                map.current.removeSource(\"connecting-line\");\n            }\n        }\n    }, [\n        focusedMovieId\n    ]);\n    /**\r\n   * Handle selected movie\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!map.current || !selectedMovie) return;\n        const bounds = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().LngLatBounds)();\n        selectedMovie.locations.forEach((location)=>{\n            bounds.extend([\n                location.lng,\n                location.lat\n            ]);\n        });\n        map.current.fitBounds(bounds, {\n            padding: 100,\n            duration: 1000\n        });\n    }, [\n        selectedMovie\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"map-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"stars-background\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 788,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapContainer,\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    position: \"relative\",\n                    zIndex: 1\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 791,\n                columnNumber: 7\n            }, undefined),\n            loadingState.isLoading && !initializedRef.current && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 z-50 flex items-center justify-center bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-center space-y-6 px-8\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-7xl animate-bounce\",\n                            children: \"\\uD83C\\uDFAC\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 798,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-3xl font-bold text-white\",\n                            children: \"CineMap\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 803,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-xl text-gray-300\",\n                            children: loadingState.stage\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 808,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-80 bg-gray-700 rounded-full h-3 overflow-hidden\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"bg-gradient-to-r from-primary-500 to-purple-600 h-full transition-all duration-300 ease-out\",\n                                style: {\n                                    width: \"\".concat(loadingState.progress, \"%\")\n                                }\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                                lineNumber: 814,\n                                columnNumber: 15\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 813,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-sm text-gray-400 font-mono\",\n                            children: [\n                                Math.round(loadingState.progress),\n                                \"%\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 821,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                    lineNumber: 796,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 795,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-20 left-4 z-10 bg-black/70 backdrop-blur-sm text-white px-4 py-2 rounded-lg shadow-xl border border-white/10\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-2xl\",\n                            children: \"\\uD83C\\uDFAC\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 831,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-xs text-gray-300\",\n                                    children: \"Total Movies\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                                    lineNumber: 833,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-xl font-bold\",\n                                    children: movies.length\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                                    lineNumber: 834,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                            lineNumber: 832,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                    lineNumber: 830,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n                lineNumber: 829,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\Map.tsx\",\n        lineNumber: 786,\n        columnNumber: 5\n    }, undefined);\n}, \"xc8zF8FNsVpSfDxFDpTgbGUda4E=\")), \"xc8zF8FNsVpSfDxFDpTgbGUda4E=\");\n_c1 = Map;\nMap.displayName = \"Map\";\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\nvar _c, _c1;\n$RefreshReg$(_c, \"Map$forwardRef\");\n$RefreshReg$(_c1, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU81Qjs7QUFFQWhDLElBQUkwTixXQUFXLEdBQUc7QUFFbEIsK0RBQWUxTixHQUFHQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL01hcC50c3g/YjE2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbi8qKlxyXG4gKiBNYXAgQ29tcG9uZW50IC0gTWFwTGlicmUgR0wgSlMgbWFwIHdpdGggZ2xvYmUgcHJvamVjdGlvbiBhbmQgbXVsdGktbG9jYXRpb24gc3VwcG9ydFxyXG4gKiBVcGRhdGVkIGZvciBOZXh0LmpzIC0gbm8gaGFzaCByb3V0aW5nLCB1c2VzIGxvY2FsU3RvcmFnZSBmb3IgbWFwIHN0YXRlXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBtYXBsaWJyZWdsIGZyb20gJ21hcGxpYnJlLWdsJ1xyXG5pbXBvcnQgdHlwZSB7IE1vdmllLCBGaWx0ZXJTdGF0ZSwgTG9jYXRpb24gfSBmcm9tICcuLi90eXBlcydcclxuaW1wb3J0IHsgZmlsdGVyTW92aWVzIH0gZnJvbSAnLi4vdXRpbHMvaGVscGVycydcclxuXHJcbmludGVyZmFjZSBNYXBQcm9wcyB7XHJcbiAgc2VsZWN0ZWRNb3ZpZTogTW92aWUgfCBudWxsXHJcbiAgb25Nb3ZpZVNlbGVjdDogKG1vdmllOiBNb3ZpZSB8IG51bGwpID0+IHZvaWRcclxuICBzZWFyY2hRdWVyeTogc3RyaW5nXHJcbiAgZmlsdGVyczogRmlsdGVyU3RhdGVcclxuICBmb2N1c2VkTW92aWVJZD86IHN0cmluZyB8IG51bGxcclxuICBvbkNsZWFyRm9jdXM/OiAoKSA9PiB2b2lkXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwUmVmIHtcclxuICBzaG93QWxsTG9jYXRpb25zRm9yTW92aWU6IChtb3ZpZTogTW92aWUpID0+IHZvaWRcclxuICBmbHlUb0xvY2F0aW9uOiAobGF0OiBudW1iZXIsIGxuZzogbnVtYmVyKSA9PiB2b2lkXHJcbiAgcmVzZXRWaWV3OiAoKSA9PiB2b2lkXHJcbn1cclxuXHJcbmludGVyZmFjZSBHZW9KU09ORmVhdHVyZSB7XHJcbiAgdHlwZTogJ0ZlYXR1cmUnXHJcbiAgaWQ6IHN0cmluZ1xyXG4gIGdlb21ldHJ5OiB7XHJcbiAgICB0eXBlOiAnUG9pbnQnIHwgJ011bHRpUG9pbnQnXHJcbiAgICBjb29yZGluYXRlczogbnVtYmVyW10gfCBudW1iZXJbXVtdXHJcbiAgfVxyXG4gIHByb3BlcnRpZXM6IHtcclxuICAgIG1vdmllX2lkOiBzdHJpbmdcclxuICAgIHRtZGJfaWQ6IG51bWJlclxyXG4gICAgdGl0bGU6IHN0cmluZ1xyXG4gICAgeWVhcjogbnVtYmVyXHJcbiAgICBwb3N0ZXI6IHN0cmluZyB8IG51bGxcclxuICAgIHRyYWlsZXI6IHN0cmluZyB8IG51bGxcclxuICAgIHRvcF9nZW5yZTogc3RyaW5nIHwgbnVsbFxyXG4gICAgZ2VucmVzPzogc3RyaW5nW11cclxuICAgIHNob3J0X2Rlc2NyaXB0aW9uOiBzdHJpbmdcclxuICAgIGltZGJfcmF0aW5nOiBudW1iZXIgfCBudWxsXHJcbiAgICBsb2NhdGlvbnNfY291bnQ6IG51bWJlclxyXG4gICAgbG9jYXRpb25fbmFtZXM6IHN0cmluZ1tdXHJcbiAgICBoYXNfdGltZWxpbmU6IGJvb2xlYW5cclxuICAgIGNlbnRyb2lkPzogW251bWJlciwgbnVtYmVyXVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgTWFwID0gZm9yd2FyZFJlZjxNYXBSZWYsIE1hcFByb3BzPigoe1xyXG4gIHNlbGVjdGVkTW92aWUsXHJcbiAgb25Nb3ZpZVNlbGVjdCxcclxuICBzZWFyY2hRdWVyeTogX3NlYXJjaFF1ZXJ5LFxyXG4gIGZpbHRlcnMsXHJcbiAgZm9jdXNlZE1vdmllSWQsXHJcbiAgb25DbGVhckZvY3VzLFxyXG59LCByZWYpID0+IHtcclxuICBjb25zdCBtYXBDb250YWluZXIgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXHJcbiAgY29uc3QgbWFwID0gdXNlUmVmPG1hcGxpYnJlZ2wuTWFwIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBbbW92aWVzLCBzZXRNb3ZpZXNdID0gdXNlU3RhdGU8TW92aWVbXT4oW10pXHJcbiAgY29uc3QgW2dlb2pzb25GZWF0dXJlcywgc2V0R2VvanNvbkZlYXR1cmVzXSA9IHVzZVN0YXRlPEdlb0pTT05GZWF0dXJlW10+KFtdKVxyXG4gIGNvbnN0IGluaXRpYWxpemVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKVxyXG5cclxuICAvLyBUcmFjayB3aGljaCBwb3N0ZXIgaW1hZ2VzIGhhdmUgYmVlbiBsb2FkZWQgdG8gcHJldmVudCByZWR1bmRhbnQgbG9hZGluZ1xyXG4gIGNvbnN0IGxvYWRlZEltYWdlc1JlZiA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKVxyXG5cclxuICAvLyBMb2FkaW5nIHN0YXRlIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcclxuICBjb25zdCBbbG9hZGluZ1N0YXRlLCBzZXRMb2FkaW5nU3RhdGVdID0gdXNlU3RhdGU8e1xyXG4gICAgaXNMb2FkaW5nOiBib29sZWFuXHJcbiAgICBwcm9ncmVzczogbnVtYmVyXHJcbiAgICBzdGFnZTogc3RyaW5nXHJcbiAgfT4oe1xyXG4gICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICBzdGFnZTogJ0luaXRpYWxpemluZy4uLidcclxuICB9KVxyXG5cclxuICAvLyBFeHBvc2UgbWV0aG9kcyB0byBwYXJlbnQgY29tcG9uZW50XHJcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XHJcbiAgICBzaG93QWxsTG9jYXRpb25zRm9yTW92aWU6IChtb3ZpZTogTW92aWUpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfl7rvuI8gTWFwLnNob3dBbGxMb2NhdGlvbnNGb3JNb3ZpZSBjYWxsZWQnLCB7XHJcbiAgICAgICAgbW92aWVJZDogbW92aWUubW92aWVfaWQsXHJcbiAgICAgICAgaGFzTWFwOiAhIW1hcC5jdXJyZW50LFxyXG4gICAgICAgIGZlYXR1cmVzTGVuZ3RoOiBnZW9qc29uRmVhdHVyZXMubGVuZ3RoXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBpZiAoIW1hcC5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE1hcCBub3QgaW5pdGlhbGl6ZWQnKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBmZWF0dXJlID0gZ2VvanNvbkZlYXR1cmVzLmZpbmQoZiA9PiBmLnByb3BlcnRpZXMubW92aWVfaWQgPT09IG1vdmllLm1vdmllX2lkKVxyXG4gICAgICBpZiAoIWZlYXR1cmUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmVhdHVyZSBub3QgZm91bmQgZm9yIG1vdmllJywgbW92aWUubW92aWVfaWQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmVhdHVyZSBmb3VuZCwgZHJhd2luZyBsaW5lcycsIGZlYXR1cmUpXHJcblxyXG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnXHJcbiAgICAgICAgPyBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIG51bWJlcltdW11cclxuICAgICAgICA6IFtmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzIGFzIG51bWJlcltdXVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfk40gQ29vcmRpbmF0ZXM6JywgY29vcmRpbmF0ZXMpXHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgYm91bmRzXHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBtYXBsaWJyZWdsLkxuZ0xhdEJvdW5kcygpXHJcbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2goY29vcmQgPT4gYm91bmRzLmV4dGVuZChjb29yZCBhcyBbbnVtYmVyLCBudW1iZXJdKSlcclxuXHJcbiAgICAgIC8vIEZpdCBtYXAgdG8gYm91bmRzXHJcbiAgICAgIG1hcC5jdXJyZW50LmZpdEJvdW5kcyhib3VuZHMsIHtcclxuICAgICAgICBwYWRkaW5nOiAxMDAsXHJcbiAgICAgICAgbWF4Wm9vbTogMTAsXHJcbiAgICAgICAgZHVyYXRpb246IDEwMDBcclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBjb25uZWN0aW5nIGxpbmVcclxuICAgICAgaWYgKG1hcC5jdXJyZW50LmdldExheWVyKCdjb25uZWN0aW5nLWxpbmUnKSkge1xyXG4gICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZUxheWVyKCdjb25uZWN0aW5nLWxpbmUnKVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChtYXAuY3VycmVudC5nZXRTb3VyY2UoJ2Nvbm5lY3RpbmctbGluZScpKSB7XHJcbiAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlU291cmNlKCdjb25uZWN0aW5nLWxpbmUnKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IGNvbm5lY3RpbmcgcG9seWxpbmUgZm9yIG11bHRpLWxvY2F0aW9uIG1vdmllc1xyXG4gICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgRHJhd2luZyBsaW5lIHdpdGgnLCBjb29yZGluYXRlcy5sZW5ndGgsICdwb2ludHMnKVxyXG4gICAgICAgIG1hcC5jdXJyZW50LmFkZFNvdXJjZSgnY29ubmVjdGluZy1saW5lJywge1xyXG4gICAgICAgICAgdHlwZTogJ2dlb2pzb24nLFxyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxyXG4gICAgICAgICAgICAgIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbWFwLmN1cnJlbnQuYWRkTGF5ZXIoe1xyXG4gICAgICAgICAgaWQ6ICdjb25uZWN0aW5nLWxpbmUnLFxyXG4gICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgc291cmNlOiAnY29ubmVjdGluZy1saW5lJyxcclxuICAgICAgICAgIHBhaW50OiB7XHJcbiAgICAgICAgICAgICdsaW5lLWNvbG9yJzogJyNGNTlFMEInLFxyXG4gICAgICAgICAgICAnbGluZS13aWR0aCc6IDQsXHJcbiAgICAgICAgICAgICdsaW5lLW9wYWNpdHknOiAwLjksXHJcbiAgICAgICAgICAgICdsaW5lLWJsdXInOiAxXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIE9ubHkgMSBsb2NhdGlvbiwgbm8gbGluZSBuZWVkZWQnKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZmx5VG9Mb2NhdGlvbjogKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcikgPT4ge1xyXG4gICAgICBpZiAobWFwLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRab29tID0gMTJcclxuXHJcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgc3dpdGNoIHRvIG1lcmNhdG9yIHByb2plY3Rpb24gZm9yIGFjY3VyYXRlIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgOyhtYXAuY3VycmVudCBhcyBhbnkpLnNldFByb2plY3Rpb24oeyB0eXBlOiAnbWVyY2F0b3InIH0pXHJcblxyXG4gICAgICAgIC8vIFVzZSBmbHlUbyBmb3Igc21vb3RoIGFuaW1hdGlvbiBpbiBtZXJjYXRvciB3aXRoIGZhc3RlciBkdXJhdGlvblxyXG4gICAgICAgIG1hcC5jdXJyZW50LmZseVRvKHtcclxuICAgICAgICAgIGNlbnRlcjogW2xuZywgbGF0XSxcclxuICAgICAgICAgIHpvb206IHRhcmdldFpvb20sXHJcbiAgICAgICAgICBkdXJhdGlvbjogMTIwMCxcclxuICAgICAgICAgIGVzc2VudGlhbDogdHJ1ZVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIFdhaXQgZm9yIG1lcmNhdG9yIGFuaW1hdGlvbiB0byBjb21wbGV0ZSwgdGhlbiBzd2l0Y2ggdG8gZ2xvYmVcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGlmICghbWFwLmN1cnJlbnQpIHJldHVyblxyXG5cclxuICAgICAgICAgIC8vIFN3aXRjaCBiYWNrIHRvIGdsb2JlIHByb2plY3Rpb25cclxuICAgICAgICAgIDsobWFwLmN1cnJlbnQgYXMgYW55KS5zZXRQcm9qZWN0aW9uKHsgdHlwZTogJ2dsb2JlJyB9KVxyXG5cclxuICAgICAgICAgIC8vIFJlLWFwcGx5IGNlbnRlciBhbmQgem9vbSBhZnRlciBnbG9iZSBzd2l0Y2ggd2l0aCBlYXNlVG8gZm9yIHNtb290aCB0cmFuc2l0aW9uXHJcbiAgICAgICAgICBtYXAuY3VycmVudC5lYXNlVG8oe1xyXG4gICAgICAgICAgICBjZW50ZXI6IFtsbmcsIGxhdF0sXHJcbiAgICAgICAgICAgIHpvb206IHRhcmdldFpvb20sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiA2MDAsXHJcbiAgICAgICAgICAgIGVzc2VudGlhbDogdHJ1ZVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9LCAxMzAwKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVzZXRWaWV3OiAoKSA9PiB7XHJcbiAgICAgIGlmIChtYXAuY3VycmVudCkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBkZWJ1ZyBtYXJrZXIgaWYgZXhpc3RzXHJcbiAgICAgICAgaWYgKG1hcC5jdXJyZW50LmdldFNvdXJjZSgnZGVidWctbWFya2VyJykpIHtcclxuICAgICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZUxheWVyKCdkZWJ1Zy1tYXJrZXInKVxyXG4gICAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlU291cmNlKCdkZWJ1Zy1tYXJrZXInKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGNvbm5lY3RpbmcgbGluZSBpZiBleGlzdHNcclxuICAgICAgICBpZiAobWFwLmN1cnJlbnQuZ2V0TGF5ZXIoJ2Nvbm5lY3RpbmctbGluZScpKSB7XHJcbiAgICAgICAgICBtYXAuY3VycmVudC5yZW1vdmVMYXllcignY29ubmVjdGluZy1saW5lJylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hcC5jdXJyZW50LmdldFNvdXJjZSgnY29ubmVjdGluZy1saW5lJykpIHtcclxuICAgICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZVNvdXJjZSgnY29ubmVjdGluZy1saW5lJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHRvIGRlZmF1bHQgdmlldyAoRXVyb3BlIGNlbnRlcmVkKVxyXG4gICAgICAgIG1hcC5jdXJyZW50LmZseVRvKHtcclxuICAgICAgICAgIGNlbnRlcjogWzAuMzUsIDQzXSxcclxuICAgICAgICAgIHpvb206IDIuODgsXHJcbiAgICAgICAgICBkdXJhdGlvbjogMTUwMCxcclxuICAgICAgICAgIGVzc2VudGlhbDogdHJ1ZVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KSwgW2dlb2pzb25GZWF0dXJlc10pXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgR2VvSlNPTiBmZWF0dXJlIHRvIE1vdmllIG9iamVjdFxyXG4gICAqL1xyXG4gIGNvbnN0IGNvbnZlcnRGZWF0dXJlVG9Nb3ZpZSA9IChmZWF0dXJlOiBHZW9KU09ORmVhdHVyZSk6IE1vdmllID0+IHtcclxuICAgIC8vIEV4dHJhY3QgbG9jYXRpb25zIGZyb20gZ2VvbWV0cnlcclxuICAgIGxldCBsb2NhdGlvbnM6IExvY2F0aW9uW10gPSBbXVxyXG5cclxuICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcclxuICAgICAgY29uc3QgW2xuZywgbGF0XSA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgYXMgbnVtYmVyW11cclxuICAgICAgbG9jYXRpb25zID0gW3tcclxuICAgICAgICBsYXQsXHJcbiAgICAgICAgbG5nLFxyXG4gICAgICAgIGNpdHk6IGZlYXR1cmUucHJvcGVydGllcy5sb2NhdGlvbl9uYW1lc1swXT8uc3BsaXQoJywnKVswXSB8fCAnVW5rbm93bicsXHJcbiAgICAgICAgY291bnRyeTogZmVhdHVyZS5wcm9wZXJ0aWVzLmxvY2F0aW9uX25hbWVzWzBdPy5zcGxpdCgnLCcpWzFdPy50cmltKCkgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmZWF0dXJlLnByb3BlcnRpZXMubG9jYXRpb25fbmFtZXNbMF0/Lm1hdGNoKC9cXCgoLio/KVxcKS8pPy5bMV0gfHwgJydcclxuICAgICAgfV1cclxuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICAgICAgY29uc3QgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyBhcyBudW1iZXJbXVtdXHJcbiAgICAgIGxvY2F0aW9ucyA9IGNvb3Jkcy5tYXAoKGNvb3JkLCBpZHgpID0+IHtcclxuICAgICAgICBjb25zdCBbbG5nLCBsYXRdID0gY29vcmRcclxuICAgICAgICBjb25zdCBsb2NhdGlvbk5hbWUgPSBmZWF0dXJlLnByb3BlcnRpZXMubG9jYXRpb25fbmFtZXNbaWR4XSB8fCAnVW5rbm93bidcclxuICAgICAgICBjb25zdCBbY2l0eSwgY291bnRyeV0gPSBsb2NhdGlvbk5hbWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSlcclxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGxvY2F0aW9uTmFtZS5tYXRjaCgvXFwoKC4qPylcXCkvKT8uWzFdIHx8ICcnXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGxhdCxcclxuICAgICAgICAgIGxuZyxcclxuICAgICAgICAgIGNpdHk6IGNpdHkgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgICAgY291bnRyeTogY291bnRyeSB8fCAnVW5rbm93bicsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtb3ZpZV9pZDogZmVhdHVyZS5wcm9wZXJ0aWVzLm1vdmllX2lkLFxyXG4gICAgICB0aXRsZTogZmVhdHVyZS5wcm9wZXJ0aWVzLnRpdGxlLFxyXG4gICAgICB5ZWFyOiBmZWF0dXJlLnByb3BlcnRpZXMueWVhcixcclxuICAgICAgaW1kYl9pZDogZmVhdHVyZS5wcm9wZXJ0aWVzLm1vdmllX2lkLFxyXG4gICAgICB0bWRiX2lkOiBTdHJpbmcoZmVhdHVyZS5wcm9wZXJ0aWVzLnRtZGJfaWQpLFxyXG4gICAgICBnZW5yZXM6IGZlYXR1cmUucHJvcGVydGllcy5nZW5yZXMgfHwgKGZlYXR1cmUucHJvcGVydGllcy50b3BfZ2VucmUgPyBbZmVhdHVyZS5wcm9wZXJ0aWVzLnRvcF9nZW5yZV0gOiBbXSksXHJcbiAgICAgIHBvc3RlcjogZmVhdHVyZS5wcm9wZXJ0aWVzLnBvc3RlciB8fCB1bmRlZmluZWQsXHJcbiAgICAgIHRyYWlsZXI6IGZlYXR1cmUucHJvcGVydGllcy50cmFpbGVyIHx8IHVuZGVmaW5lZCxcclxuICAgICAgaW1kYl9yYXRpbmc6IGZlYXR1cmUucHJvcGVydGllcy5pbWRiX3JhdGluZyB8fCB1bmRlZmluZWQsXHJcbiAgICAgIGxvY2F0aW9ucyxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgbW92aWVzIGRhdGEgYW5kIEdlb0pTT04gd2l0aCBwcm9ncmVzc2l2ZSBsb2FkaW5nXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIExvYWQgR2VvSlNPTiBmZWF0dXJlc1xyXG4gICAgICAgIGNvbnN0IGdlb2pzb25SZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvZ2VvL21vdmllcy5nZW9qc29uJylcclxuICAgICAgICBjb25zdCBnZW9qc29uRGF0YSA9IGF3YWl0IGdlb2pzb25SZXNwb25zZS5qc29uKClcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgYWxsIGZlYXR1cmVzIGZvciBmaWx0ZXJpbmdcclxuICAgICAgICBzZXRHZW9qc29uRmVhdHVyZXMoZ2VvanNvbkRhdGEuZmVhdHVyZXMpXHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYWxsIEdlb0pTT04gZmVhdHVyZXMgdG8gTW92aWUgb2JqZWN0c1xyXG4gICAgICAgIGNvbnN0IG1vdmllc0Zyb21HZW9KU09OOiBNb3ZpZVtdID0gZ2VvanNvbkRhdGEuZmVhdHVyZXMubWFwKGNvbnZlcnRGZWF0dXJlVG9Nb3ZpZSlcclxuICAgICAgICBzZXRNb3ZpZXMobW92aWVzRnJvbUdlb0pTT04pXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIExvYWRlZCAke2dlb2pzb25EYXRhLmZlYXR1cmVzLmxlbmd0aH0gbW92aWVzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdgKVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGRhdGE6JywgZXJyb3IpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGxvYWREYXRhKClcclxuICB9LCBbXSlcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBtYXBcclxuICAgKi9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXBDb250YWluZXIuY3VycmVudCB8fCBtYXAuY3VycmVudCkgcmV0dXJuXHJcblxyXG4gICAgbWFwLmN1cnJlbnQgPSBuZXcgbWFwbGlicmVnbC5NYXAoe1xyXG4gICAgICBjb250YWluZXI6IG1hcENvbnRhaW5lci5jdXJyZW50LFxyXG4gICAgICAvLyBVc2UgTWFwVGlsZXIgYmFzaWMgc3R5bGUgLSBmcmVlIHRpZXIsIHdvcmtzIHdpdGggZ2xvYmVcclxuICAgICAgc3R5bGU6ICdodHRwczovL2FwaS5tYXB0aWxlci5jb20vbWFwcy9iYXNpYy12Mi9zdHlsZS5qc29uP2tleT1nZXRfeW91cl9vd25fT3BJaTlaVUxOSHpyRVN2NlQydkwnLFxyXG4gICAgICB6b29tOiAyLjg4LFxyXG4gICAgICBjZW50ZXI6IFswLjM1LCA0M10sIC8vIENlbnRlcmVkIG9uIEV1cm9wZVxyXG4gICAgICAvLyBoYXNoOiB0cnVlIC8vIFJlbW92ZWQgZm9yIE5leHQuanMgLSB1c2luZyBsb2NhbFN0b3JhZ2UgZm9yIGNsZWFuIFVSTHNcclxuICAgIH0pXHJcblxyXG4gICAgLy8gR2xvYmUgcm90YXRpb24gYW5pbWF0aW9uXHJcbiAgICBsZXQgaXNVc2VySW50ZXJhY3RpbmcgPSBmYWxzZVxyXG4gICAgbGV0IHJvdGF0aW9uQW5pbWF0aW9uOiBudW1iZXIgfCBudWxsID0gbnVsbFxyXG5cclxuICAgIGNvbnN0IHN0YXJ0Um90YXRpb24gPSAoKSA9PiB7XHJcbiAgICAgIGlmICghbWFwLmN1cnJlbnQgfHwgaXNVc2VySW50ZXJhY3RpbmcpIHJldHVyblxyXG5cclxuICAgICAgY29uc3Qgcm90YXRlQ2FtZXJhID0gKF90aW1lc3RhbXA6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGlmICghbWFwLmN1cnJlbnQgfHwgaXNVc2VySW50ZXJhY3RpbmcpIHJldHVyblxyXG5cclxuICAgICAgICAvLyBSb3RhdGUgMzYwIGRlZ3JlZXMgb3ZlciAyIG1pbnV0ZXMgKDEyMCBzZWNvbmRzKVxyXG4gICAgICAgIGNvbnN0IHNlY29uZHNQZXJSZXZvbHV0aW9uID0gNzIwXHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gbWFwLmN1cnJlbnQuZ2V0Q2VudGVyKClcclxuICAgICAgICBjZW50ZXIubG5nID0gKGNlbnRlci5sbmcgKyAoMzYwIC8gc2Vjb25kc1BlclJldm9sdXRpb24pICogKDEvNjApKSAlIDM2MFxyXG4gICAgICAgIG1hcC5jdXJyZW50LnNldENlbnRlcihjZW50ZXIpXHJcblxyXG4gICAgICAgIHJvdGF0aW9uQW5pbWF0aW9uID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJvdGF0ZUNhbWVyYSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcm90YXRpb25BbmltYXRpb24gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocm90YXRlQ2FtZXJhKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0b3BSb3RhdGlvbiA9ICgpID0+IHtcclxuICAgICAgaXNVc2VySW50ZXJhY3RpbmcgPSB0cnVlXHJcbiAgICAgIGlmIChyb3RhdGlvbkFuaW1hdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJvdGF0aW9uQW5pbWF0aW9uKVxyXG4gICAgICAgIHJvdGF0aW9uQW5pbWF0aW9uID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbWFwLmN1cnJlbnQub24oJ3N0eWxlLmxvYWQnLCAoKSA9PiB7XHJcbiAgICAgIGlmIChtYXAuY3VycmVudCkge1xyXG4gICAgICAgIC8vIFNldCBwcm9qZWN0aW9uIHRvIGdsb2JlXHJcbiAgICAgICAgKG1hcC5jdXJyZW50IGFzIGFueSkuc2V0UHJvamVjdGlvbih7XHJcbiAgICAgICAgICB0eXBlOiAnZ2xvYmUnLFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgbWFwIHBvc2l0aW9uIGZyb20gbG9jYWxTdG9yYWdlIChjbGVhbiBVUkxzKVxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgY29uc3Qgc2F2ZWRTdGF0ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaW5lbWFwX3ZpZXcnKVxyXG4gICAgICAgICAgaWYgKHNhdmVkU3RhdGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCB7IGxhdCwgbG5nLCB6b29tIH0gPSBKU09OLnBhcnNlKHNhdmVkU3RhdGUpXHJcbiAgICAgICAgICAgICAgbWFwLmN1cnJlbnQuc2V0Q2VudGVyKFtsbmcsIGxhdF0pXHJcbiAgICAgICAgICAgICAgbWFwLmN1cnJlbnQuc2V0Wm9vbSh6b29tKVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgLy8gSWdub3JlIGludmFsaWQgc3RvcmVkIHN0YXRlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IHJvdGF0aW9uIGFmdGVyIG1hcCBsb2Fkc1xyXG4gICAgICAgIHNldFRpbWVvdXQoc3RhcnRSb3RhdGlvbiwgMTAwMClcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBTYXZlIG1hcCBwb3NpdGlvbiB0byBsb2NhbFN0b3JhZ2Ugb24gbW92ZW1lbnQgKGRlYm91bmNlZClcclxuICAgIGxldCBzYXZlVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxyXG4gICAgY29uc3Qgc2F2ZU1hcFN0YXRlID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIW1hcC5jdXJyZW50IHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cclxuICAgICAgY29uc3QgY2VudGVyID0gbWFwLmN1cnJlbnQuZ2V0Q2VudGVyKClcclxuICAgICAgY29uc3Qgem9vbSA9IG1hcC5jdXJyZW50LmdldFpvb20oKVxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY2luZW1hcF92aWV3JywgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGxhdDogY2VudGVyLmxhdCxcclxuICAgICAgICBsbmc6IGNlbnRlci5sbmcsXHJcbiAgICAgICAgem9vbTogem9vbVxyXG4gICAgICB9KSlcclxuICAgIH1cclxuXHJcbiAgICBtYXAuY3VycmVudC5vbignbW92ZWVuZCcsICgpID0+IHtcclxuICAgICAgaWYgKHNhdmVUaW1lb3V0KSBjbGVhclRpbWVvdXQoc2F2ZVRpbWVvdXQpXHJcbiAgICAgIHNhdmVUaW1lb3V0ID0gc2V0VGltZW91dChzYXZlTWFwU3RhdGUsIDUwMClcclxuICAgIH0pXHJcblxyXG4gICAgLy8gU3RvcCByb3RhdGlvbiBvbiBhbnkgdXNlciBpbnRlcmFjdGlvblxyXG4gICAgbWFwLmN1cnJlbnQub24oJ21vdXNlZG93bicsIHN0b3BSb3RhdGlvbilcclxuICAgIG1hcC5jdXJyZW50Lm9uKCd0b3VjaHN0YXJ0Jywgc3RvcFJvdGF0aW9uKVxyXG4gICAgbWFwLmN1cnJlbnQub24oJ3doZWVsJywgc3RvcFJvdGF0aW9uKVxyXG4gICAgbWFwLmN1cnJlbnQub24oJ2RyYWdzdGFydCcsIHN0b3BSb3RhdGlvbilcclxuXHJcbiAgICAvLyBBZGQgbmF2aWdhdGlvbiBjb250cm9sc1xyXG4gICAgbWFwLmN1cnJlbnQuYWRkQ29udHJvbChuZXcgbWFwbGlicmVnbC5OYXZpZ2F0aW9uQ29udHJvbCgpLCAnYm90dG9tLXJpZ2h0JylcclxuICAgIG1hcC5jdXJyZW50LmFkZENvbnRyb2wobmV3IG1hcGxpYnJlZ2wuRnVsbHNjcmVlbkNvbnRyb2woKSwgJ2JvdHRvbS1yaWdodCcpXHJcblxyXG4gICAgLy8gRG9uJ3QgYWRkIHpvb20gbGlzdGVuZXIgaGVyZSAtIGl0IGNhdXNlcyBpc3N1ZXMgd2l0aCB0aWxlIGxvYWRpbmdcclxuICAgIC8vIFdlJ2xsIGhhbmRsZSBpdCBkaWZmZXJlbnRseVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChtYXAuY3VycmVudCkge1xyXG4gICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZSgpXHJcbiAgICAgICAgbWFwLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBhbmQgY3JlYXRlIHBvc3RlciBpbWFnZSBpY29uIHdpdGggbW92aWUgYmFkZ2VcclxuICAgKi9cclxuICBjb25zdCBjcmVhdGVQb3N0ZXJJY29uID0gYXN5bmMgKHBvc3RlclBhdGg6IHN0cmluZyB8IG51bGwsIF9tb3ZpZUlkOiBzdHJpbmcsIF9pc011bHRpTG9jYXRpb246IGJvb2xlYW4pOiBQcm9taXNlPHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXI7IGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5IH0+ID0+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBjb25zdCBzaXplID0gNjAgLy8gQ29uc2lzdGVudCBzaXplIGZvciBhbGwgbWFya2Vyc1xyXG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICBjYW52YXMud2lkdGggPSBzaXplXHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplXHJcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIVxyXG5cclxuICAgICAgLy8gSWYgbm8gcG9zdGVyLCBjcmVhdGUgZmFsbGJhY2sgaWNvblxyXG4gICAgICBpZiAoIXBvc3RlclBhdGgpIHtcclxuICAgICAgICAvLyBDcmVhdGUgY2lyY3VsYXIgYmFja2dyb3VuZFxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgIGN0eC5hcmMoc2l6ZSAvIDIsIHNpemUgLyAyLCBzaXplIC8gMiwgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjM0I4MkY2J1xyXG4gICAgICAgIGN0eC5maWxsKClcclxuXHJcbiAgICAgICAgLy8gV2hpdGUgYm9yZGVyXHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNGRkZGRkYnXHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDNcclxuICAgICAgICBjdHguc3Ryb2tlKClcclxuXHJcbiAgICAgICAgLy8gRmlsbSBpY29uXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJ1xyXG4gICAgICAgIGN0eC5mb250ID0gJ2JvbGQgMjRweCBBcmlhbCdcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcidcclxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSdcclxuICAgICAgICBjdHguZmlsbFRleHQoJ/CfjqwnLCBzaXplIC8gMiwgc2l6ZSAvIDIpXHJcblxyXG4gICAgICAgIHJlc29sdmUoeyB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplLCBkYXRhOiBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUsIHNpemUpLmRhdGEgfSlcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBwb3N0ZXIgaW1hZ2VcclxuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcclxuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcclxuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAvLyBDcmVhdGUgY2lyY3VsYXIgY2xpcHBpbmcgbWFza1xyXG4gICAgICAgIGN0eC5zYXZlKClcclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHguYXJjKHNpemUgLyAyLCBzaXplIC8gMiwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgIGN0eC5jbGlwKClcclxuXHJcbiAgICAgICAgLy8gRHJhdyBwb3N0ZXIgKGNlbnRlcmVkIGFuZCBzY2FsZWQpXHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHNpemUsIHNpemUpXHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKVxyXG5cclxuICAgICAgICAvLyBXaGl0ZSBib3JkZXIgYXJvdW5kIGNpcmNsZVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgIGN0eC5hcmMoc2l6ZSAvIDIsIHNpemUgLyAyLCBzaXplIC8gMiwgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyMxMGJlNTBmZidcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gM1xyXG4gICAgICAgIGN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICByZXNvbHZlKHsgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSwgZGF0YTogY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLCBzaXplKS5kYXRhIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrIG9uIGVycm9yIC0gY2lyY3VsYXIgaWNvblxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgIGN0eC5hcmMoc2l6ZSAvIDIsIHNpemUgLyAyLCBzaXplIC8gMiwgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjM0I4MkY2J1xyXG4gICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI0ZGRkZGRidcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gM1xyXG4gICAgICAgIGN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICAvLyBGaWxtIGljb24gZmFsbGJhY2tcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNGRkZGRkYnXHJcbiAgICAgICAgY3R4LmZvbnQgPSAnYm9sZCAyMHB4IEFyaWFsJ1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJ1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJ1xyXG4gICAgICAgIGN0eC5maWxsVGV4dCgn8J+OrCcsIHNpemUgLyAyLCBzaXplIC8gMilcclxuXHJcbiAgICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUsIGRhdGE6IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZSwgc2l6ZSkuZGF0YSB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVc2UgdGhlIGZ1bGwgcG9zdGVyIFVSTCBmcm9tIHRoZSBkYXRhXHJcbiAgICAgIGltZy5zcmMgPSBwb3N0ZXJQYXRoXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIG1vdmllIG1hcmtlcnMgZnJvbSBHZW9KU09OIC0gSU5JVElBTCBMT0FEIE9OTFlcclxuICAgKi9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXAuY3VycmVudCB8fCBnZW9qc29uRmVhdHVyZXMubGVuZ3RoID09PSAwKSByZXR1cm5cclxuXHJcbiAgICAvLyBPbmx5IHJ1biB0aGlzIGVmZmVjdCBvbmNlIHdoZW4gZGF0YSBpcyBmaXJzdCBsb2FkZWRcclxuICAgIGlmIChpbml0aWFsaXplZFJlZi5jdXJyZW50IHx8IG1hcC5jdXJyZW50LmdldFNvdXJjZSgnbW92aWVzJykpIHJldHVyblxyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVNYXJrZXJzKCkge1xyXG4gICAgICBpZiAoIW1hcC5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICAgIC8vIExvYWQgQUxMIHBvc3RlcnMgQkVGT1JFIGFkZGluZyBtYXAgbGF5ZXIgKHByZXZlbnRzIHdhcm5pbmdzKVxyXG4gICAgICBjb25zdCBCQVRDSF9TSVpFID0gMjBcclxuICAgICAgbGV0IGxvYWRlZENvdW50ID0gMFxyXG4gICAgICBjb25zdCBhbGxGZWF0dXJlcyA9IGdlb2pzb25GZWF0dXJlc1xyXG5cclxuICAgICAgLy8gT25seSBzaG93IGxvYWRpbmcgb24gaW5pdGlhbCBzZXR1cCwgbm90IG9uIFN0cmljdE1vZGUgcmUtbW91bnRzXHJcbiAgICAgIGlmICghaW5pdGlhbGl6ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHNldExvYWRpbmdTdGF0ZSh7XHJcbiAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXHJcbiAgICAgICAgICBwcm9ncmVzczogOTAsXHJcbiAgICAgICAgICBzdGFnZTogYExvYWRpbmcgcG9zdGVycy4uLiAwLyR7YWxsRmVhdHVyZXMubGVuZ3RofWBcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMb2FkIHBvc3RlcnMgaW4gYmF0Y2hlcyBhbmQgYXdhaXQgY29tcGxldGlvblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEZlYXR1cmVzLmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XHJcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBhbGxGZWF0dXJlcy5zbGljZShpLCBpICsgQkFUQ0hfU0laRSlcclxuXHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICBiYXRjaC5tYXAoYXN5bmMgKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW92aWVJZCA9IGZlYXR1cmUucHJvcGVydGllcy5tb3ZpZV9pZFxyXG4gICAgICAgICAgICBjb25zdCBwb3N0ZXJQYXRoID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnBvc3RlclxyXG4gICAgICAgICAgICBjb25zdCBpc011bHRpTG9jYXRpb24gPSBmZWF0dXJlLnByb3BlcnRpZXMubG9jYXRpb25zX2NvdW50ID4gMVxyXG4gICAgICAgICAgICBjb25zdCBpY29uTmFtZSA9IGBwb3N0ZXItJHttb3ZpZUlkfWBcclxuXHJcbiAgICAgICAgICAgIGlmICghbWFwLmN1cnJlbnQhLmhhc0ltYWdlKGljb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0ZXJJY29uID0gYXdhaXQgY3JlYXRlUG9zdGVySWNvbihwb3N0ZXJQYXRoLCBtb3ZpZUlkLCBpc011bHRpTG9jYXRpb24pXHJcbiAgICAgICAgICAgICAgICBtYXAuY3VycmVudCEuYWRkSW1hZ2UoaWNvbk5hbWUsIHBvc3Rlckljb24pXHJcbiAgICAgICAgICAgICAgICBsb2FkZWRJbWFnZXNSZWYuY3VycmVudC5hZGQoaWNvbk5hbWUpIC8vIE1hcmsgYXMgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICBsb2FkZWRDb3VudCsrXHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBhZGQgcG9zdGVyIGljb24gZm9yICR7bW92aWVJZH06YCwgZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgZmFsbGJhY2sgaWNvbiBvbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tJY29uID0gYXdhaXQgY3JlYXRlUG9zdGVySWNvbihudWxsLCBtb3ZpZUlkLCBpc011bHRpTG9jYXRpb24pXHJcbiAgICAgICAgICAgICAgICBtYXAuY3VycmVudCEuYWRkSW1hZ2UoaWNvbk5hbWUsIGZhbGxiYWNrSWNvbilcclxuICAgICAgICAgICAgICAgIGxvYWRlZEltYWdlc1JlZi5jdXJyZW50LmFkZChpY29uTmFtZSkgLy8gTWFyayBhcyBsb2FkZWRcclxuICAgICAgICAgICAgICAgIGxvYWRlZENvdW50KytcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbG9hZGVkQ291bnQrK1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIGFmdGVyIGVhY2ggYmF0Y2hcclxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoKGxvYWRlZENvdW50IC8gYWxsRmVhdHVyZXMubGVuZ3RoKSAqIDEwMClcclxuICAgICAgICBzZXRMb2FkaW5nU3RhdGUoe1xyXG4gICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgICAgICAgcHJvZ3Jlc3M6IDkwICsgKHByb2dyZXNzICogMC4wOSksIC8vIDkwLTk5JSByYW5nZVxyXG4gICAgICAgICAgc3RhZ2U6IGBMb2FkaW5nIHBvc3RlcnMuLi4gJHtsb2FkZWRDb3VudH0vJHthbGxGZWF0dXJlcy5sZW5ndGh9YFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNob3cgcmVuZGVyaW5nIHN0YWdlIG9ubHkgb24gaW5pdGlhbCBzZXR1cFxyXG4gICAgICBpZiAoIWluaXRpYWxpemVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzZXRMb2FkaW5nU3RhdGUoe1xyXG4gICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgICAgICAgcHJvZ3Jlc3M6IDk5LFxyXG4gICAgICAgICAgc3RhZ2U6ICdSZW5kZXJpbmcgbWFya2Vycy4uLidcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IE11bHRpUG9pbnQgZmVhdHVyZXMgaW50byBpbmRpdmlkdWFsIFBvaW50IGZlYXR1cmVzIGZvciBlYWNoIGxvY2F0aW9uXHJcbiAgICAgIGNvbnN0IGRpc3BsYXlGZWF0dXJlczogYW55W10gPSBbXVxyXG5cclxuICAgICAgYWxsRmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcclxuICAgICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNlcGFyYXRlIGZlYXR1cmUgZm9yIGVhY2ggbG9jYXRpb25cclxuICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgYXMgbnVtYmVyW11bXVxyXG4gICAgICAgICAgY29vcmRzLmZvckVhY2goKGNvb3JkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBkaXNwbGF5RmVhdHVyZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgLi4uZmVhdHVyZSxcclxuICAgICAgICAgICAgICBpZDogYCR7ZmVhdHVyZS5pZH0tbG9jLSR7aW5kZXh9YCxcclxuICAgICAgICAgICAgICBnZW9tZXRyeToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1BvaW50JyBhcyBjb25zdCxcclxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFNpbmdsZSBsb2NhdGlvbiAtIGtlZXAgYXMgaXNcclxuICAgICAgICAgIGRpc3BsYXlGZWF0dXJlcy5wdXNoKGZlYXR1cmUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIEdlb0pTT04gZm9yIGRpc3BsYXlcclxuICAgICAgY29uc3QgZ2VvanNvbjogR2VvSlNPTi5GZWF0dXJlQ29sbGVjdGlvbiA9IHtcclxuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gICAgICAgIGZlYXR1cmVzOiBkaXNwbGF5RmVhdHVyZXMgYXMgYW55XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBzb3VyY2UgLSBESVNBQkxFIGNsdXN0ZXJpbmcgc28gbWFya2VycyBzdGF5IHZpc2libGVcclxuICAgICAgbWFwLmN1cnJlbnQhLmFkZFNvdXJjZSgnbW92aWVzJywge1xyXG4gICAgICAgIHR5cGU6ICdnZW9qc29uJyxcclxuICAgICAgICBkYXRhOiBnZW9qc29uLFxyXG4gICAgICAgIC8vIENsdXN0ZXJpbmcgZGlzYWJsZWQgLSB3ZSB3YW50IHRvIHNlZSBhbGwgbWFya2Vyc1xyXG4gICAgICAgIGNsdXN0ZXI6IGZhbHNlLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gQWRkIGFsbCBtb3ZpZSBtYXJrZXJzIGxheWVyIChub3cgZWFjaCBtYXJrZXIgcmVwcmVzZW50cyBvbmUgYWN0dWFsIGxvY2F0aW9uKVxyXG4gICAgICBtYXAuY3VycmVudCEuYWRkTGF5ZXIoe1xyXG4gICAgICAgIGlkOiAnbW92aWUtbWFya2VycycsXHJcbiAgICAgICAgdHlwZTogJ3N5bWJvbCcsXHJcbiAgICAgICAgc291cmNlOiAnbW92aWVzJyxcclxuICAgICAgICBsYXlvdXQ6IHtcclxuICAgICAgICAgICdpY29uLWltYWdlJzogWydjb25jYXQnLCAncG9zdGVyLScsIFsnZ2V0JywgJ21vdmllX2lkJ11dLFxyXG4gICAgICAgICAgJ2ljb24tc2l6ZSc6IDAuNyxcclxuICAgICAgICAgICdpY29uLWFsbG93LW92ZXJsYXAnOiB0cnVlLFxyXG4gICAgICAgICAgJ3RleHQtZmllbGQnOiBbJ2dldCcsICd0aXRsZSddLFxyXG4gICAgICAgICAgJ3RleHQtZm9udCc6IFsnT3BlbiBTYW5zIEJvbGQnLCAnQXJpYWwgVW5pY29kZSBNUyBCb2xkJ10sXHJcbiAgICAgICAgICAndGV4dC1zaXplJzogMTQsXHJcbiAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgMi44XSxcclxuICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICd0b3AnLFxyXG4gICAgICAgICAgJ3RleHQtbWF4LXdpZHRoJzogMTIsXHJcbiAgICAgICAgICAndGV4dC1hbGxvdy1vdmVybGFwJzogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhaW50OiB7XHJcbiAgICAgICAgICAndGV4dC1jb2xvcic6ICcjMTBiZTUwZmYnLFxyXG4gICAgICAgICAgJ3RleHQtaGFsby1jb2xvcic6ICcjMUYyOTM3JyxcclxuICAgICAgICAgICd0ZXh0LWhhbG8td2lkdGgnOiAyLjUsXHJcbiAgICAgICAgICAndGV4dC1oYWxvLWJsdXInOiAxXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gQWxsIGRvbmUgLSBoaWRlIGxvYWRpbmcgc2NyZWVuIG9ubHkgb24gaW5pdGlhbCBzZXR1cFxyXG4gICAgICBpZiAoIWluaXRpYWxpemVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHNldExvYWRpbmdTdGF0ZSh7IGlzTG9hZGluZzogZmFsc2UsIHByb2dyZXNzOiAxMDAsIHN0YWdlOiAnQ29tcGxldGUnIH0pXHJcbiAgICAgICAgICBpbml0aWFsaXplZFJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIH0sIDMwMCkgLy8gU21hbGwgZGVsYXkgZm9yIHNtb290aCB0cmFuc2l0aW9uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCB1bmlmaWVkIGNsaWNrIGhhbmRsZXIgZm9yIGFsbCBtb3ZpZSBtYXJrZXJzXHJcbiAgICAgIGNvbnN0IGhhbmRsZU1hcmtlckNsaWNrID0gKGU6IGFueSkgPT4ge1xyXG4gICAgICAgIGlmICghZS5mZWF0dXJlcyB8fCBlLmZlYXR1cmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXHJcblxyXG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBlLmZlYXR1cmVzWzBdXHJcblxyXG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGluIGdlb2pzb25GZWF0dXJlcyBieSBtb3ZpZV9pZFxyXG4gICAgICAgIGNvbnN0IGZlYXR1cmVCeU1vdmllSWQgPSBnZW9qc29uRmVhdHVyZXMuZmluZChmID0+IGYucHJvcGVydGllcy5tb3ZpZV9pZCA9PT0gZmVhdHVyZS5wcm9wZXJ0aWVzLm1vdmllX2lkKVxyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUJ5TW92aWVJZCkge1xyXG4gICAgICAgICAgY29uc3QgbW92aWVGcm9tRmVhdHVyZSA9IGNvbnZlcnRGZWF0dXJlVG9Nb3ZpZShmZWF0dXJlQnlNb3ZpZUlkKVxyXG4gICAgICAgICAgb25Nb3ZpZVNlbGVjdChtb3ZpZUZyb21GZWF0dXJlKVxyXG4gICAgICAgICAgLy8gRG9uJ3QgYXV0b21hdGljYWxseSBzaG93IGFsbCBsb2NhdGlvbnMgLSBsZXQgdXNlciBjbGljayBcIlNob3cgQWxsIG9uIE1hcFwiIGJ1dHRvblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBMYXN0IHJlc29ydDogY3JlYXRlIGEgbWluaW1hbCBtb3ZpZSBvYmplY3RcclxuICAgICAgICAgIGNvbnN0IG1vdmllRnJvbUNsaWNrID0ge1xyXG4gICAgICAgICAgICBtb3ZpZV9pZDogZmVhdHVyZS5wcm9wZXJ0aWVzLm1vdmllX2lkLFxyXG4gICAgICAgICAgICB0aXRsZTogZmVhdHVyZS5wcm9wZXJ0aWVzLnRpdGxlLFxyXG4gICAgICAgICAgICB5ZWFyOiBmZWF0dXJlLnByb3BlcnRpZXMueWVhcixcclxuICAgICAgICAgICAgaW1kYl9pZDogZmVhdHVyZS5wcm9wZXJ0aWVzLm1vdmllX2lkLFxyXG4gICAgICAgICAgICB0bWRiX2lkOiBTdHJpbmcoZmVhdHVyZS5wcm9wZXJ0aWVzLnRtZGJfaWQpLFxyXG4gICAgICAgICAgICBnZW5yZXM6IGZlYXR1cmUucHJvcGVydGllcy5nZW5yZXMgfHwgKGZlYXR1cmUucHJvcGVydGllcy50b3BfZ2VucmUgPyBbZmVhdHVyZS5wcm9wZXJ0aWVzLnRvcF9nZW5yZV0gOiBbXSksXHJcbiAgICAgICAgICAgIHBvc3RlcjogZmVhdHVyZS5wcm9wZXJ0aWVzLnBvc3RlciB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHRyYWlsZXI6IGZlYXR1cmUucHJvcGVydGllcy50cmFpbGVyIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgaW1kYl9yYXRpbmc6IGZlYXR1cmUucHJvcGVydGllcy5pbWRiX3JhdGluZyB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uczogW3tcclxuICAgICAgICAgICAgICBsYXQ6IDAsXHJcbiAgICAgICAgICAgICAgbG5nOiAwLFxyXG4gICAgICAgICAgICAgIGNpdHk6ICdVbmtub3duJyxcclxuICAgICAgICAgICAgICBjb3VudHJ5OiAnVW5rbm93bicsXHJcbiAgICAgICAgICAgIH1dLCAvLyBNaW5pbWFsIGxvY2F0aW9uIHRvIHByZXZlbnQgY3Jhc2hcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9uTW92aWVTZWxlY3QobW92aWVGcm9tQ2xpY2sgYXMgTW92aWUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXAuY3VycmVudCEub24oJ2NsaWNrJywgJ21vdmllLW1hcmtlcnMnLCBoYW5kbGVNYXJrZXJDbGljaylcclxuXHJcbiAgICAgIC8vIENsZWFyIGZvY3VzIHdoZW4gY2xpY2tpbmcgb24gZW1wdHkgbWFwIChub3Qgb24gbWFya2VycylcclxuICAgICAgY29uc3QgaGFuZGxlTWFwQ2xpY2sgPSAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgLy8gT25seSBjbGVhciBmb2N1cyBpZiBjbGlja2luZyBvbiBlbXB0eSBzcGFjZSAobm90IG9uIG1hcmtlcnMpXHJcbiAgICAgICAgaWYgKCFlLmZlYXR1cmVzIHx8IGUuZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAoZm9jdXNlZE1vdmllSWQgJiYgb25DbGVhckZvY3VzKSB7XHJcbiAgICAgICAgICAgIG9uQ2xlYXJGb2N1cygpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXAuY3VycmVudCEub24oJ2NsaWNrJywgaGFuZGxlTWFwQ2xpY2spXHJcblxyXG4gICAgICAvLyBDaGFuZ2UgY3Vyc29yIG9uIGhvdmVyXHJcbiAgICAgIG1hcC5jdXJyZW50IS5vbignbW91c2VlbnRlcicsICdtb3ZpZS1tYXJrZXJzJywgKCkgPT4ge1xyXG4gICAgICAgIG1hcC5jdXJyZW50IS5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcidcclxuICAgICAgfSlcclxuICAgICAgbWFwLmN1cnJlbnQhLm9uKCdtb3VzZWxlYXZlJywgJ21vdmllLW1hcmtlcnMnLCAoKSA9PiB7XHJcbiAgICAgICAgbWFwLmN1cnJlbnQhLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICcnXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2FpdCBmb3Igc3R5bGUgdG8gYmUgbG9hZGVkXHJcbiAgICBpZiAoIW1hcC5jdXJyZW50LmlzU3R5bGVMb2FkZWQoKSkge1xyXG4gICAgICBtYXAuY3VycmVudC5vbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICBpbml0aWFsaXplTWFya2VycygpXHJcbiAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbml0aWFsaXplTWFya2VycygpXHJcbiAgICB9XHJcbiAgfSwgW2dlb2pzb25GZWF0dXJlc10pIC8vIE9ubHkgZGVwZW5kIG9uIGdlb2pzb25GZWF0dXJlcyAtIHJ1biBvbmNlIHdoZW4gZGF0YSBsb2Fkc1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdmlzaWJsZSBtYXJrZXJzIGJhc2VkIG9uIGZpbHRlcnMgYW5kIGZvY3VzIC0gTk8gUkVCVUlMRElOR1xyXG4gICAqL1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcC5jdXJyZW50IHx8ICFtYXAuY3VycmVudC5nZXRTb3VyY2UoJ21vdmllcycpKSByZXR1cm5cclxuXHJcbiAgICBsZXQgZmlsdGVyZWRGZWF0dXJlczogR2VvSlNPTkZlYXR1cmVbXVxyXG5cclxuICAgIC8vIElmIGEgbW92aWUgaXMgZm9jdXNlZCwgT05MWSBzaG93IHRoYXQgbW92aWUncyBtYXJrZXJzIChpZ25vcmUgYWxsIG90aGVyIGZpbHRlcnMpXHJcbiAgICBpZiAoZm9jdXNlZE1vdmllSWQpIHtcclxuICAgICAgZmlsdGVyZWRGZWF0dXJlcyA9IGdlb2pzb25GZWF0dXJlcy5maWx0ZXIoZiA9PiBmLnByb3BlcnRpZXMubW92aWVfaWQgPT09IGZvY3VzZWRNb3ZpZUlkKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gTm9ybWFsIG1vZGU6IGFwcGx5IHNlYXJjaCBhbmQgZmlsdGVyIGxvZ2ljXHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkTW92aWVzID0gZmlsdGVyTW92aWVzKG1vdmllcywgZmlsdGVycylcclxuICAgICAgY29uc3QgZmlsdGVyZWRJZHMgPSBuZXcgU2V0KGZpbHRlcmVkTW92aWVzLm1hcChtID0+IG0ubW92aWVfaWQpKVxyXG5cclxuICAgICAgZmlsdGVyZWRGZWF0dXJlcyA9IG1vdmllcy5sZW5ndGggPiAwXHJcbiAgICAgICAgPyBnZW9qc29uRmVhdHVyZXMuZmlsdGVyKGYgPT4gZmlsdGVyZWRJZHMuaGFzKGYucHJvcGVydGllcy5tb3ZpZV9pZCkpXHJcbiAgICAgICAgOiBnZW9qc29uRmVhdHVyZXNcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IE11bHRpUG9pbnQgZmVhdHVyZXMgaW50byBpbmRpdmlkdWFsIFBvaW50IGZlYXR1cmVzXHJcbiAgICBjb25zdCBkaXNwbGF5RmVhdHVyZXM6IGFueVtdID0gW11cclxuXHJcbiAgICBmaWx0ZXJlZEZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgYXMgbnVtYmVyW11bXVxyXG4gICAgICAgIGNvb3Jkcy5mb3JFYWNoKChjb29yZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGRpc3BsYXlGZWF0dXJlcy5wdXNoKHtcclxuICAgICAgICAgICAgLi4uZmVhdHVyZSxcclxuICAgICAgICAgICAgaWQ6IGAke2ZlYXR1cmUuaWR9LWxvYy0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ1BvaW50JyBhcyBjb25zdCxcclxuICAgICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpc3BsYXlGZWF0dXJlcy5wdXNoKGZlYXR1cmUpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBkYXRhIHNvdXJjZSBXSVRIT1VUIHJlYnVpbGRpbmcgbGF5ZXJzIC0gSU5TVEFOVCFcclxuICAgIGNvbnN0IGdlb2pzb246IEdlb0pTT04uRmVhdHVyZUNvbGxlY3Rpb24gPSB7XHJcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgICAgIGZlYXR1cmVzOiBkaXNwbGF5RmVhdHVyZXMgYXMgYW55XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gbWFwLmN1cnJlbnQuZ2V0U291cmNlKCdtb3ZpZXMnKSBhcyBtYXBsaWJyZWdsLkdlb0pTT05Tb3VyY2VcclxuICAgIGlmIChzb3VyY2UgJiYgc291cmNlLnNldERhdGEpIHtcclxuICAgICAgc291cmNlLnNldERhdGEoZ2VvanNvbilcclxuICAgIH1cclxuICB9LCBbZ2VvanNvbkZlYXR1cmVzLCBtb3ZpZXMsIGZpbHRlcnMsIGZvY3VzZWRNb3ZpZUlkXSkgLy8gVXBkYXRlIGRhdGEgd2hlbiBmaWx0ZXJzL2ZvY3VzIGNoYW5nZVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBjb25uZWN0aW5nIGxpbmVzIHdoZW4gZm9jdXMgaXMgcmVtb3ZlZFxyXG4gICAqL1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW1hcC5jdXJyZW50KSByZXR1cm5cclxuXHJcbiAgICAvLyBXaGVuIGZvY3VzZWRNb3ZpZUlkIGlzIGNsZWFyZWQsIHJlbW92ZSB0aGUgY29ubmVjdGluZyBsaW5lc1xyXG4gICAgaWYgKCFmb2N1c2VkTW92aWVJZCkge1xyXG4gICAgICBpZiAobWFwLmN1cnJlbnQuZ2V0TGF5ZXIoJ2Nvbm5lY3RpbmctbGluZScpKSB7XHJcbiAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlTGF5ZXIoJ2Nvbm5lY3RpbmctbGluZScpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKG1hcC5jdXJyZW50LmdldFNvdXJjZSgnY29ubmVjdGluZy1saW5lJykpIHtcclxuICAgICAgICBtYXAuY3VycmVudC5yZW1vdmVTb3VyY2UoJ2Nvbm5lY3RpbmctbGluZScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbZm9jdXNlZE1vdmllSWRdKVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgc2VsZWN0ZWQgbW92aWVcclxuICAgKi9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXAuY3VycmVudCB8fCAhc2VsZWN0ZWRNb3ZpZSkgcmV0dXJuXHJcblxyXG4gICAgY29uc3QgYm91bmRzID0gbmV3IG1hcGxpYnJlZ2wuTG5nTGF0Qm91bmRzKClcclxuICAgIHNlbGVjdGVkTW92aWUubG9jYXRpb25zLmZvckVhY2goKGxvY2F0aW9uKSA9PiB7XHJcbiAgICAgIGJvdW5kcy5leHRlbmQoW2xvY2F0aW9uLmxuZywgbG9jYXRpb24ubGF0XSlcclxuICAgIH0pXHJcblxyXG4gICAgbWFwLmN1cnJlbnQuZml0Qm91bmRzKGJvdW5kcywge1xyXG4gICAgICBwYWRkaW5nOiAxMDAsXHJcbiAgICAgIGR1cmF0aW9uOiAxMDAwLFxyXG4gICAgfSlcclxuICB9LCBbc2VsZWN0ZWRNb3ZpZV0pXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hcC1jb250YWluZXJcIj5cclxuICAgICAgey8qIFN0YXJzIGJhY2tncm91bmQgKi99XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3RhcnMtYmFja2dyb3VuZFwiIC8+XHJcblxyXG4gICAgICB7LyogTWFwIGNvbnRhaW5lciAqL31cclxuICAgICAgPGRpdiByZWY9e21hcENvbnRhaW5lcn0gc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCB6SW5kZXg6IDEgfX0gLz5cclxuXHJcbiAgICAgIHsvKiBMb2FkaW5nIFNjcmVlbiBPdmVybGF5IC0gT25seSBzaG93IG9uIGluaXRpYWwgbG9hZCAqL31cclxuICAgICAge2xvYWRpbmdTdGF0ZS5pc0xvYWRpbmcgJiYgIWluaXRpYWxpemVkUmVmLmN1cnJlbnQgJiYgKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCB6LTUwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWdyYWRpZW50LXRvLWJyIGZyb20tZ3JheS05MDAgdmlhLXB1cnBsZS05MDAgdG8tZ3JheS05MDBcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgc3BhY2UteS02IHB4LThcIj5cclxuICAgICAgICAgICAgey8qIE1vdmllIGVtb2ppIGFuaW1hdGlvbiAqL31cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTd4bCBhbmltYXRlLWJvdW5jZVwiPlxyXG4gICAgICAgICAgICAgIPCfjqxcclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICB7LyogVGl0bGUgKi99XHJcbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC13aGl0ZVwiPlxyXG4gICAgICAgICAgICAgIENpbmVNYXBcclxuICAgICAgICAgICAgPC9oMj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBMb2FkaW5nIHN0YWdlIHRleHQgKi99XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteGwgdGV4dC1ncmF5LTMwMFwiPlxyXG4gICAgICAgICAgICAgIHtsb2FkaW5nU3RhdGUuc3RhZ2V9XHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIHsvKiBQcm9ncmVzcyBiYXIgKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy04MCBiZy1ncmF5LTcwMCByb3VuZGVkLWZ1bGwgaC0zIG92ZXJmbG93LWhpZGRlblwiPlxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWdyYWRpZW50LXRvLXIgZnJvbS1wcmltYXJ5LTUwMCB0by1wdXJwbGUtNjAwIGgtZnVsbCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1vdXRcIlxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IGAke2xvYWRpbmdTdGF0ZS5wcm9ncmVzc30lYCB9fVxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgey8qIFByb2dyZXNzIHBlcmNlbnRhZ2UgKi99XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMCBmb250LW1vbm9cIj5cclxuICAgICAgICAgICAgICB7TWF0aC5yb3VuZChsb2FkaW5nU3RhdGUucHJvZ3Jlc3MpfSVcclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcblxyXG4gICAgICB7LyogTW92aWUgY291bnQgYmFkZ2UgKi99XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTIwIGxlZnQtNCB6LTEwIGJnLWJsYWNrLzcwIGJhY2tkcm9wLWJsdXItc20gdGV4dC13aGl0ZSBweC00IHB5LTIgcm91bmRlZC1sZyBzaGFkb3cteGwgYm9yZGVyIGJvcmRlci13aGl0ZS8xMFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cclxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtMnhsXCI+8J+OrDwvc3Bhbj5cclxuICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTMwMFwiPlRvdGFsIE1vdmllczwvcD5cclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGRcIj5cclxuICAgICAgICAgICAgICB7bW92aWVzLmxlbmd0aH1cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59KVxyXG5cclxuTWFwLmRpc3BsYXlOYW1lID0gJ01hcCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hcFxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiZm9yd2FyZFJlZiIsIm1hcGxpYnJlZ2wiLCJmaWx0ZXJNb3ZpZXMiLCJNYXAiLCJyZWYiLCJzZWxlY3RlZE1vdmllIiwib25Nb3ZpZVNlbGVjdCIsInNlYXJjaFF1ZXJ5IiwiX3NlYXJjaFF1ZXJ5IiwiZmlsdGVycyIsImZvY3VzZWRNb3ZpZUlkIiwib25DbGVhckZvY3VzIiwibWFwQ29udGFpbmVyIiwibWFwIiwibW92aWVzIiwic2V0TW92aWVzIiwiZ2VvanNvbkZlYXR1cmVzIiwic2V0R2VvanNvbkZlYXR1cmVzIiwiaW5pdGlhbGl6ZWRSZWYiLCJsb2FkZWRJbWFnZXNSZWYiLCJTZXQiLCJsb2FkaW5nU3RhdGUiLCJzZXRMb2FkaW5nU3RhdGUiLCJpc0xvYWRpbmciLCJwcm9ncmVzcyIsInN0YWdlIiwic2hvd0FsbExvY2F0aW9uc0Zvck1vdmllIiwibW92aWUiLCJjb25zb2xlIiwibG9nIiwibW92aWVJZCIsIm1vdmllX2lkIiwiaGFzTWFwIiwiY3VycmVudCIsImZlYXR1cmVzTGVuZ3RoIiwibGVuZ3RoIiwiZXJyb3IiLCJmZWF0dXJlIiwiZmluZCIsImYiLCJwcm9wZXJ0aWVzIiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeSIsInR5cGUiLCJib3VuZHMiLCJMbmdMYXRCb3VuZHMiLCJmb3JFYWNoIiwiY29vcmQiLCJleHRlbmQiLCJmaXRCb3VuZHMiLCJwYWRkaW5nIiwibWF4Wm9vbSIsImR1cmF0aW9uIiwiZ2V0TGF5ZXIiLCJyZW1vdmVMYXllciIsImdldFNvdXJjZSIsInJlbW92ZVNvdXJjZSIsImFkZFNvdXJjZSIsImRhdGEiLCJhZGRMYXllciIsImlkIiwic291cmNlIiwicGFpbnQiLCJmbHlUb0xvY2F0aW9uIiwibGF0IiwibG5nIiwidGFyZ2V0Wm9vbSIsInNldFByb2plY3Rpb24iLCJmbHlUbyIsImNlbnRlciIsInpvb20iLCJlc3NlbnRpYWwiLCJzZXRUaW1lb3V0IiwiZWFzZVRvIiwicmVzZXRWaWV3IiwiY29udmVydEZlYXR1cmVUb01vdmllIiwibG9jYXRpb25zIiwiY2l0eSIsImxvY2F0aW9uX25hbWVzIiwic3BsaXQiLCJjb3VudHJ5IiwidHJpbSIsImRlc2NyaXB0aW9uIiwibWF0Y2giLCJjb29yZHMiLCJpZHgiLCJsb2NhdGlvbk5hbWUiLCJzIiwidGl0bGUiLCJ5ZWFyIiwiaW1kYl9pZCIsInRtZGJfaWQiLCJTdHJpbmciLCJnZW5yZXMiLCJ0b3BfZ2VucmUiLCJwb3N0ZXIiLCJ1bmRlZmluZWQiLCJ0cmFpbGVyIiwiaW1kYl9yYXRpbmciLCJsb2FkRGF0YSIsImdlb2pzb25SZXNwb25zZSIsImZldGNoIiwiZ2VvanNvbkRhdGEiLCJqc29uIiwiZmVhdHVyZXMiLCJtb3ZpZXNGcm9tR2VvSlNPTiIsImNvbnRhaW5lciIsInN0eWxlIiwiaXNVc2VySW50ZXJhY3RpbmciLCJyb3RhdGlvbkFuaW1hdGlvbiIsInN0YXJ0Um90YXRpb24iLCJyb3RhdGVDYW1lcmEiLCJfdGltZXN0YW1wIiwic2Vjb25kc1BlclJldm9sdXRpb24iLCJnZXRDZW50ZXIiLCJzZXRDZW50ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdG9wUm90YXRpb24iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uIiwic2F2ZWRTdGF0ZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzZXRab29tIiwiZSIsInNhdmVUaW1lb3V0Iiwic2F2ZU1hcFN0YXRlIiwiZ2V0Wm9vbSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjbGVhclRpbWVvdXQiLCJhZGRDb250cm9sIiwiTmF2aWdhdGlvbkNvbnRyb2wiLCJGdWxsc2NyZWVuQ29udHJvbCIsInJlbW92ZSIsImNyZWF0ZVBvc3Rlckljb24iLCJwb3N0ZXJQYXRoIiwiX21vdmllSWQiLCJfaXNNdWx0aUxvY2F0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzaXplIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiYmVnaW5QYXRoIiwiYXJjIiwiTWF0aCIsIlBJIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiZm9udCIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZ2V0SW1hZ2VEYXRhIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsInNhdmUiLCJjbGlwIiwiZHJhd0ltYWdlIiwicmVzdG9yZSIsIm9uZXJyb3IiLCJzcmMiLCJpbml0aWFsaXplTWFya2VycyIsIkJBVENIX1NJWkUiLCJsb2FkZWRDb3VudCIsImFsbEZlYXR1cmVzIiwiaSIsImJhdGNoIiwic2xpY2UiLCJhbGwiLCJpc011bHRpTG9jYXRpb24iLCJsb2NhdGlvbnNfY291bnQiLCJpY29uTmFtZSIsImhhc0ltYWdlIiwicG9zdGVySWNvbiIsImFkZEltYWdlIiwiYWRkIiwiZmFsbGJhY2tJY29uIiwicm91bmQiLCJkaXNwbGF5RmVhdHVyZXMiLCJpbmRleCIsInB1c2giLCJnZW9qc29uIiwiY2x1c3RlciIsImxheW91dCIsImhhbmRsZU1hcmtlckNsaWNrIiwiZmVhdHVyZUJ5TW92aWVJZCIsIm1vdmllRnJvbUZlYXR1cmUiLCJtb3ZpZUZyb21DbGljayIsImhhbmRsZU1hcENsaWNrIiwiZ2V0Q2FudmFzIiwiY3Vyc29yIiwiaXNTdHlsZUxvYWRlZCIsImZpbHRlcmVkRmVhdHVyZXMiLCJmaWx0ZXIiLCJmaWx0ZXJlZE1vdmllcyIsImZpbHRlcmVkSWRzIiwibSIsImhhcyIsInNldERhdGEiLCJsb2NhdGlvbiIsImRpdiIsImNsYXNzTmFtZSIsInBvc2l0aW9uIiwiekluZGV4IiwiaDIiLCJwIiwic3BhbiIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6785\n"));

/***/ }),

/***/ 1274:
/*!***************************************!*\
  !*** ./src/components/MapWrapper.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ 3068);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ 2265);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Map */ 6785);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n/**\r\n * MapWrapper - Wrapper to ensure proper ref forwarding with Next.js dynamic imports\r\n */ \n\nconst MapWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = (props, ref)=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Map__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        ...props,\n        ref: ref\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Arturas\\\\Desktop\\\\cinemap\\\\src\\\\components\\\\MapWrapper.tsx\",\n        lineNumber: 22,\n        columnNumber: 10\n    }, undefined);\n});\n_c1 = MapWrapper;\nMapWrapper.displayName = \"MapWrapper\";\n/* harmony default export */ __webpack_exports__[\"default\"] = (MapWrapper);\nvar _c, _c1;\n$RefreshReg$(_c, \"MapWrapper$forwardRef\");\n$RefreshReg$(_c1, \"MapWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQTs7Q0FFQyxHQUVpQztBQUNYO0FBYXZCLE1BQU1FLDJCQUFhRixpREFBVUEsTUFBbUIsQ0FBQ0csT0FBT0M7SUFDdEQscUJBQU8sOERBQUNILDRDQUFHQTtRQUFFLEdBQUdFLEtBQUs7UUFBRUMsS0FBS0E7Ozs7OztBQUM5Qjs7QUFFQUYsV0FBV0csV0FBVyxHQUFHO0FBRXpCLCtEQUFlSCxVQUFVQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL01hcFdyYXBwZXIudHN4PzEzZmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG4vKipcclxuICogTWFwV3JhcHBlciAtIFdyYXBwZXIgdG8gZW5zdXJlIHByb3BlciByZWYgZm9yd2FyZGluZyB3aXRoIE5leHQuanMgZHluYW1pYyBpbXBvcnRzXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgTWFwIGZyb20gJy4vTWFwJ1xyXG5pbXBvcnQgdHlwZSB7IE1hcFJlZiB9IGZyb20gJy4vTWFwJ1xyXG5pbXBvcnQgdHlwZSB7IE1vdmllLCBGaWx0ZXJTdGF0ZSB9IGZyb20gJy4uL3R5cGVzJ1xyXG5cclxuaW50ZXJmYWNlIE1hcFByb3BzIHtcclxuICBzZWxlY3RlZE1vdmllOiBNb3ZpZSB8IG51bGxcclxuICBvbk1vdmllU2VsZWN0OiAobW92aWU6IE1vdmllIHwgbnVsbCkgPT4gdm9pZFxyXG4gIHNlYXJjaFF1ZXJ5OiBzdHJpbmdcclxuICBmaWx0ZXJzOiBGaWx0ZXJTdGF0ZVxyXG4gIGZvY3VzZWRNb3ZpZUlkPzogc3RyaW5nIHwgbnVsbFxyXG4gIG9uQ2xlYXJGb2N1cz86ICgpID0+IHZvaWRcclxufVxyXG5cclxuY29uc3QgTWFwV3JhcHBlciA9IGZvcndhcmRSZWY8TWFwUmVmLCBNYXBQcm9wcz4oKHByb3BzLCByZWYpID0+IHtcclxuICByZXR1cm4gPE1hcCB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPlxyXG59KVxyXG5cclxuTWFwV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdNYXBXcmFwcGVyJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWFwV3JhcHBlclxyXG4iXSwibmFtZXMiOlsiZm9yd2FyZFJlZiIsIk1hcCIsIk1hcFdyYXBwZXIiLCJwcm9wcyIsInJlZiIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1274\n"));

/***/ }),

/***/ 2630:
/*!******************************!*\
  !*** ./src/utils/helpers.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   debounce: function() { return /* binding */ debounce; },\n/* harmony export */   filterMovies: function() { return /* binding */ filterMovies; },\n/* harmony export */   formatRating: function() { return /* binding */ formatRating; },\n/* harmony export */   formatYearRange: function() { return /* binding */ formatYearRange; },\n/* harmony export */   getUniqueCountries: function() { return /* binding */ getUniqueCountries; },\n/* harmony export */   getUniqueGenres: function() { return /* binding */ getUniqueGenres; },\n/* harmony export */   getUniqueStreamingPlatforms: function() { return /* binding */ getUniqueStreamingPlatforms; },\n/* harmony export */   getYouTubeEmbedUrl: function() { return /* binding */ getYouTubeEmbedUrl; },\n/* harmony export */   getYouTubeVideoId: function() { return /* binding */ getYouTubeVideoId; }\n/* harmony export */ });\n/**\r\n * General utility functions\r\n */ /**\r\n * Format year range for display\r\n */ const formatYearRange = (start, end)=>{\n    if (start === end) return \"\".concat(start);\n    return \"\".concat(start, \"-\").concat(end);\n};\n/**\r\n * Get unique list of genres from movies\r\n */ const getUniqueGenres = (movies)=>{\n    const genresSet = new Set();\n    movies.forEach((movie)=>{\n        movie.genres.forEach((genre)=>genresSet.add(genre));\n    });\n    return Array.from(genresSet).sort();\n};\n/**\r\n * Get unique list of streaming platforms\r\n */ const getUniqueStreamingPlatforms = (movies)=>{\n    const platformsSet = new Set();\n    movies.forEach((movie)=>{\n        var _movie_streaming;\n        (_movie_streaming = movie.streaming) === null || _movie_streaming === void 0 ? void 0 : _movie_streaming.forEach((platform)=>platformsSet.add(platform));\n    });\n    return Array.from(platformsSet).sort();\n};\n/**\r\n * Get unique list of countries\r\n */ const getUniqueCountries = (movies)=>{\n    const countriesSet = new Set();\n    movies.forEach((movie)=>{\n        movie.locations.forEach((loc)=>countriesSet.add(loc.country));\n    });\n    return Array.from(countriesSet).sort();\n};\n/**\r\n * Filter movies by criteria\r\n */ const filterMovies = (movies, filters)=>{\n    return movies.filter((movie)=>{\n        // Genre filter\n        if (filters.genres.length > 0) {\n            const hasMatchingGenre = movie.genres.some((genre)=>filters.genres.includes(genre));\n            if (!hasMatchingGenre) return false;\n        }\n        // Decade filter\n        if (movie.year < filters.decades[0] || movie.year > filters.decades[1]) {\n            return false;\n        }\n        // Streaming filter\n        if (filters.streaming.length > 0 && movie.streaming) {\n            const hasMatchingPlatform = movie.streaming.some((platform)=>filters.streaming.includes(platform));\n            if (!hasMatchingPlatform) return false;\n        }\n        return true;\n    });\n};\n/**\r\n * Debounce function for search input\r\n */ const debounce = (func, wait)=>{\n    let timeout = null;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(()=>func(...args), wait);\n    };\n};\n/**\r\n * Format IMDb rating for display\r\n */ const formatRating = (rating)=>{\n    if (!rating) return \"N/A\";\n    return rating.toFixed(1);\n};\n/**\r\n * Extract YouTube video ID from URL\r\n */ const getYouTubeVideoId = (url)=>{\n    if (!url) return null;\n    const match = url.match(/[?&]v=([^&]+)/);\n    return match ? match[1] : null;\n};\n/**\r\n * Generate YouTube embed URL\r\n */ const getYouTubeEmbedUrl = (url)=>{\n    const videoId = getYouTubeVideoId(url);\n    return videoId ? \"https://www.youtube.com/embed/\".concat(videoId) : null;\n};\n/**\r\n * Clamp a number between min and max\r\n */ const clamp = (value, min, max)=>{\n    return Math.min(Math.max(value, min), max);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2pCLE1BQU1DLFFBQVFELElBQUlDLEtBQUssQ0FBQztJQUN4QixPQUFPQSxRQUFRQSxLQUFLLENBQUMsRUFBRSxHQUFHO0FBQzVCLEVBQUM7QUFFRDs7Q0FFQyxHQUNNLE1BQU1DLHFCQUFxQixDQUFDRjtJQUNqQyxNQUFNRyxVQUFVSixrQkFBa0JDO0lBQ2xDLE9BQU9HLFVBQVUsaUNBQXlDLE9BQVJBLFdBQVk7QUFDaEUsRUFBQztBQUVEOztDQUVDLEdBQ00sTUFBTUMsUUFBUSxDQUFDQyxPQUFlQyxLQUFhQztJQUNoRCxPQUFPQyxLQUFLRixHQUFHLENBQUNFLEtBQUtELEdBQUcsQ0FBQ0YsT0FBT0MsTUFBTUM7QUFDeEMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvaGVscGVycy50cz82OWFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBHZW5lcmFsIHV0aWxpdHkgZnVuY3Rpb25zXHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUgeyBNb3ZpZSB9IGZyb20gJy4uL3R5cGVzJ1xyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCB5ZWFyIHJhbmdlIGZvciBkaXNwbGF5XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZm9ybWF0WWVhclJhbmdlID0gKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBpZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuIGAke3N0YXJ0fWBcclxuICByZXR1cm4gYCR7c3RhcnR9LSR7ZW5kfWBcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgbGlzdCBvZiBnZW5yZXMgZnJvbSBtb3ZpZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVbmlxdWVHZW5yZXMgPSAobW92aWVzOiByZWFkb25seSBNb3ZpZVtdKTogc3RyaW5nW10gPT4ge1xyXG4gIGNvbnN0IGdlbnJlc1NldCA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgbW92aWVzLmZvckVhY2gobW92aWUgPT4ge1xyXG4gICAgbW92aWUuZ2VucmVzLmZvckVhY2goZ2VucmUgPT4gZ2VucmVzU2V0LmFkZChnZW5yZSkpXHJcbiAgfSlcclxuICByZXR1cm4gQXJyYXkuZnJvbShnZW5yZXNTZXQpLnNvcnQoKVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHVuaXF1ZSBsaXN0IG9mIHN0cmVhbWluZyBwbGF0Zm9ybXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVbmlxdWVTdHJlYW1pbmdQbGF0Zm9ybXMgPSAobW92aWVzOiByZWFkb25seSBNb3ZpZVtdKTogc3RyaW5nW10gPT4ge1xyXG4gIGNvbnN0IHBsYXRmb3Jtc1NldCA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgbW92aWVzLmZvckVhY2gobW92aWUgPT4ge1xyXG4gICAgbW92aWUuc3RyZWFtaW5nPy5mb3JFYWNoKHBsYXRmb3JtID0+IHBsYXRmb3Jtc1NldC5hZGQocGxhdGZvcm0pKVxyXG4gIH0pXHJcbiAgcmV0dXJuIEFycmF5LmZyb20ocGxhdGZvcm1zU2V0KS5zb3J0KClcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgbGlzdCBvZiBjb3VudHJpZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVbmlxdWVDb3VudHJpZXMgPSAobW92aWVzOiByZWFkb25seSBNb3ZpZVtdKTogc3RyaW5nW10gPT4ge1xyXG4gIGNvbnN0IGNvdW50cmllc1NldCA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgbW92aWVzLmZvckVhY2gobW92aWUgPT4ge1xyXG4gICAgbW92aWUubG9jYXRpb25zLmZvckVhY2gobG9jID0+IGNvdW50cmllc1NldC5hZGQobG9jLmNvdW50cnkpKVxyXG4gIH0pXHJcbiAgcmV0dXJuIEFycmF5LmZyb20oY291bnRyaWVzU2V0KS5zb3J0KClcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbHRlciBtb3ZpZXMgYnkgY3JpdGVyaWFcclxuICovXHJcbmV4cG9ydCBjb25zdCBmaWx0ZXJNb3ZpZXMgPSAoXHJcbiAgbW92aWVzOiByZWFkb25seSBNb3ZpZVtdLFxyXG4gIGZpbHRlcnM6IHtcclxuICAgIGdlbnJlczogc3RyaW5nW11cclxuICAgIGRlY2FkZXM6IFtudW1iZXIsIG51bWJlcl1cclxuICAgIHN0cmVhbWluZzogc3RyaW5nW11cclxuICB9XHJcbik6IE1vdmllW10gPT4ge1xyXG4gIHJldHVybiBtb3ZpZXMuZmlsdGVyKG1vdmllID0+IHtcclxuICAgIC8vIEdlbnJlIGZpbHRlclxyXG4gICAgaWYgKGZpbHRlcnMuZ2VucmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgaGFzTWF0Y2hpbmdHZW5yZSA9IG1vdmllLmdlbnJlcy5zb21lKGdlbnJlID0+XHJcbiAgICAgICAgZmlsdGVycy5nZW5yZXMuaW5jbHVkZXMoZ2VucmUpXHJcbiAgICAgIClcclxuICAgICAgaWYgKCFoYXNNYXRjaGluZ0dlbnJlKSByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWNhZGUgZmlsdGVyXHJcbiAgICBpZiAobW92aWUueWVhciA8IGZpbHRlcnMuZGVjYWRlc1swXSB8fCBtb3ZpZS55ZWFyID4gZmlsdGVycy5kZWNhZGVzWzFdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmVhbWluZyBmaWx0ZXJcclxuICAgIGlmIChmaWx0ZXJzLnN0cmVhbWluZy5sZW5ndGggPiAwICYmIG1vdmllLnN0cmVhbWluZykge1xyXG4gICAgICBjb25zdCBoYXNNYXRjaGluZ1BsYXRmb3JtID0gbW92aWUuc3RyZWFtaW5nLnNvbWUocGxhdGZvcm0gPT5cclxuICAgICAgICBmaWx0ZXJzLnN0cmVhbWluZy5pbmNsdWRlcyhwbGF0Zm9ybSlcclxuICAgICAgKVxyXG4gICAgICBpZiAoIWhhc01hdGNoaW5nUGxhdGZvcm0pIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIERlYm91bmNlIGZ1bmN0aW9uIGZvciBzZWFyY2ggaW5wdXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWJvdW5jZSA9IDxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxyXG4gIGZ1bmM6IFQsXHJcbiAgd2FpdDogbnVtYmVyXHJcbik6ICgoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4gdm9pZCkgPT4ge1xyXG4gIGxldCB0aW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGwgPSBudWxsXHJcblxyXG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KVxyXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZnVuYyguLi5hcmdzKSwgd2FpdClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgSU1EYiByYXRpbmcgZm9yIGRpc3BsYXlcclxuICovXHJcbmV4cG9ydCBjb25zdCBmb3JtYXRSYXRpbmcgPSAocmF0aW5nPzogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBpZiAoIXJhdGluZykgcmV0dXJuICdOL0EnXHJcbiAgcmV0dXJuIHJhdGluZy50b0ZpeGVkKDEpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IFlvdVR1YmUgdmlkZW8gSUQgZnJvbSBVUkxcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRZb3VUdWJlVmlkZW9JZCA9ICh1cmw/OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICBpZiAoIXVybCkgcmV0dXJuIG51bGxcclxuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvWz8mXXY9KFteJl0rKS8pXHJcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBZb3VUdWJlIGVtYmVkIFVSTFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFlvdVR1YmVFbWJlZFVybCA9ICh1cmw/OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICBjb25zdCB2aWRlb0lkID0gZ2V0WW91VHViZVZpZGVvSWQodXJsKVxyXG4gIHJldHVybiB2aWRlb0lkID8gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLyR7dmlkZW9JZH1gIDogbnVsbFxyXG59XHJcblxyXG4vKipcclxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNsYW1wID0gKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpXHJcbn1cclxuIl0sIm5hbWVzIjpbImZvcm1hdFllYXJSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZ2V0VW5pcXVlR2VucmVzIiwibW92aWVzIiwiZ2VucmVzU2V0IiwiU2V0IiwiZm9yRWFjaCIsIm1vdmllIiwiZ2VucmVzIiwiZ2VucmUiLCJhZGQiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiZ2V0VW5pcXVlU3RyZWFtaW5nUGxhdGZvcm1zIiwicGxhdGZvcm1zU2V0Iiwic3RyZWFtaW5nIiwicGxhdGZvcm0iLCJnZXRVbmlxdWVDb3VudHJpZXMiLCJjb3VudHJpZXNTZXQiLCJsb2NhdGlvbnMiLCJsb2MiLCJjb3VudHJ5IiwiZmlsdGVyTW92aWVzIiwiZmlsdGVycyIsImZpbHRlciIsImxlbmd0aCIsImhhc01hdGNoaW5nR2VucmUiLCJzb21lIiwiaW5jbHVkZXMiLCJ5ZWFyIiwiZGVjYWRlcyIsImhhc01hdGNoaW5nUGxhdGZvcm0iLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwidGltZW91dCIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZm9ybWF0UmF0aW5nIiwicmF0aW5nIiwidG9GaXhlZCIsImdldFlvdVR1YmVWaWRlb0lkIiwidXJsIiwibWF0Y2giLCJnZXRZb3VUdWJlRW1iZWRVcmwiLCJ2aWRlb0lkIiwiY2xhbXAiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsIk1hdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2630\n"));

/***/ })

}]);